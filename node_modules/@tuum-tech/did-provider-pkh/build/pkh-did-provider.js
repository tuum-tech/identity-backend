"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PkhDIDProvider = exports.checkHederaAccount = exports.createClient = exports.toEthereumAddress = void 0;
const transactions_1 = require("@ethersproject/transactions");
const did_manager_1 = require("@veramo/did-manager");
const sdk_1 = require("@hashgraph/sdk");
const debug_1 = __importDefault(require("debug"));
const software_private_key_1 = require("./hedera/software-private-key");
const hedera_client_1 = require("./hedera/hedera-client");
const hedera_1 = require("./hedera");
const debug = (0, debug_1.default)('veramo:did-pkh:identifier-provider');
/**
* Helper method that can computes the ethereumAddress corresponding to a Secp256k1 public key.
* @param hexPublicKey A hex encoded public key, optionally prefixed with `0x`
*/
function toEthereumAddress(hexPublicKey) {
    const publicKey = hexPublicKey.startsWith('0x') ? hexPublicKey : '0x' + hexPublicKey;
    return (0, transactions_1.computeAddress)(publicKey);
}
exports.toEthereumAddress = toEthereumAddress;
function createClient(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = sdk_1.Client.forNetwork(options.network);
        const transactionSigner = yield options.walletHedera.getTransactionSigner(options.keyIndex);
        const privateKey = yield options.walletHedera.getPrivateKey(options.keyIndex);
        const publicKey = yield options.walletHedera.getPublicKey(options.keyIndex);
        let pubkey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toStringRaw();
        let pubkeyAdd = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toEthereumAddress();
        // TODO: Fix
        client.setOperatorWith(options.accountId, publicKey !== null && publicKey !== void 0 ? publicKey : '', transactionSigner);
        if (!(yield (0, hedera_1.testClientOperatorMatch)(client))) {
            return null;
        }
        return new hedera_client_1.SimpleHederaClientImpl(client, privateKey);
    });
}
exports.createClient = createClient;
function checkHederaAccount(_privateKey, _accountId, _chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        //const hederaChainIDs = getHederaChainIDs();
        //const chain_id = await getCurrentNetwork(wallet);
        //if (Array.from(hederaChainIDs.keys()).includes(chain_id)) {
        const accountId = sdk_1.AccountId.fromString(_accountId);
        const privateKey = sdk_1.PrivateKey.fromStringECDSA(_privateKey);
        const publicKey = privateKey.publicKey;
        const walletHedera = new software_private_key_1.PrivateKeySoftwareWallet(privateKey);
        const client = yield createClient({
            walletHedera,
            keyIndex: 0,
            accountId: accountId,
            network: _chainId,
        });
        if (client != null) {
            const info = yield client.getAccountInfo(_accountId);
            // state.hederaAccount.evmAddress = info.contractAccountId;
            // if (state.hederaAccount.evmAddress !== state.currentAccount) {
            //   state.currentAccount = state.hederaAccount.evmAddress;
            // }
            // state.hederaAccount.privateKey = privateKey.toStringRaw();
            // state.hederaAccount.publicKey = publicKey.toStringRaw();
            // state.hederaAccount.accountId = accountId.toString();
            // await updateSnapState(wallet, state);
            return true;
        }
        else {
            console.error('Invalid private key or account Id');
            return false;
        }
        // const client = await createClient({
        //   walletHedera,
        //   keyIndex: 0,
        //   accountId: accountId,
        //   network: _chainId,
        // });
        // if (client != null) {
        //   const info = await client.getAccountInfo(_accountId);
        //   state.hederaAccount.evmAddress = info.contractAccountId;
        //   if (state.hederaAccount.evmAddress !== state.currentAccount) {
        //     state.currentAccount = state.hederaAccount.evmAddress;
        //   }
        //   state.hederaAccount.privateKey = privateKey.toStringRaw();
        //   state.hederaAccount.publicKey = publicKey.toStringRaw();
        //   state.hederaAccount.accountId = accountId.toString();
        //   await updateSnapState(wallet, state);
        //   return true;
        // } else {
        //   console.error('Invalid private key or account Id');
        //   return false;
        // }
    });
}
exports.checkHederaAccount = checkHederaAccount;
/**
 * {@link @veramo/did-manager#DIDManager} identifier provider for `did:pkh` identifiers
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class PkhDIDProvider extends did_manager_1.AbstractIdentifierProvider {
    constructor(options) {
        super();
        this.defaultKms = options.defaultKms;
    }
    createIdentifier({ kms, options }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let key = null;
            if ((options === null || options === void 0 ? void 0 : options.network) === "hedera") {
                let isAccountValid = yield checkHederaAccount(options.privateKey, options.hederaAccountId, options.chainId);
                if (isAccountValid === false) {
                    console.error("invalid");
                    throw new Error("invalid");
                }
                key = yield context.agent.keyManagerImport({ kms: kms || this.defaultKms, type: 'Secp256k1', privateKeyHex: options.privateKey });
            }
            else {
                key = yield context.agent.keyManagerCreate({ kms: kms || this.defaultKms, type: 'Secp256k1' });
            }
            const publicAddress = (options === null || options === void 0 ? void 0 : options.network) === 'eip155' ? toEthereumAddress(key.publicKeyHex) : options === null || options === void 0 ? void 0 : options.hederaAccountId;
            const chainId = options === null || options === void 0 ? void 0 : options.chainId;
            if (!chainId) {
                throw new Error(`invalid_setup: Cannot create did:pkh. There is no known configuration for network=${chainId}'`);
            }
            const identifier = {
                did: 'did:pkh:' + options.network + ':' + chainId + ':' + publicAddress,
                controllerKeyId: key.kid,
                keys: [key],
                services: [],
            };
            debug('Created', identifier.did);
            return identifier;
        });
    }
    updateIdentifier(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('PkhDIDProvider updateIdentifier not supported yet.');
        });
    }
    deleteIdentifier(identifier, context) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const { kid } of identifier.keys) {
                yield context.agent.keyManagerDelete({ kid });
            }
            return true;
        });
    }
    addKey({ identifier, key, options }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error('PkhDIDProvider addKey not supported');
        });
    }
    addService({ identifier, service, options }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error('PkhDIDProvider addService not supported');
        });
    }
    removeKey(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error('PkhDIDProvider removeKey not supported');
        });
    }
    removeService(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error('PkhDIDProvider removeService not supported');
        });
    }
}
exports.PkhDIDProvider = PkhDIDProvider;
//# sourceMappingURL=pkh-did-provider.js.map