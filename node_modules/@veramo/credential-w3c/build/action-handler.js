"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialPlugin = void 0;
const core_1 = require("@veramo/core");
const did_jwt_vc_1 = require("did-jwt-vc");
const did_jwt_1 = require("did-jwt");
const utils_1 = require("@veramo/utils");
const debug_1 = __importDefault(require("debug"));
const canonicalize_1 = __importDefault(require("canonicalize"));
var DocumentFormat;
(function (DocumentFormat) {
    DocumentFormat[DocumentFormat["JWT"] = 0] = "JWT";
    DocumentFormat[DocumentFormat["JSONLD"] = 1] = "JSONLD";
    DocumentFormat[DocumentFormat["EIP712"] = 2] = "EIP712";
})(DocumentFormat || (DocumentFormat = {}));
const debug = (0, debug_1.default)('veramo:w3c:action-handler');
/**
 * A Veramo plugin that implements the {@link @veramo/core#ICredentialPlugin | ICredentialPlugin} methods.
 *
 * @public
 */
class CredentialPlugin {
    constructor() {
        this.schema = {
            components: {
                schemas: Object.assign(Object.assign({}, core_1.schema.ICredentialIssuer.components.schemas), core_1.schema.ICredentialVerifier.components.schemas),
                methods: Object.assign(Object.assign({}, core_1.schema.ICredentialIssuer.components.methods), core_1.schema.ICredentialVerifier.components.methods)
            }
        };
        this.methods = {
            createVerifiablePresentation: this.createVerifiablePresentation.bind(this),
            createVerifiableCredential: this.createVerifiableCredential.bind(this),
            verifyCredential: this.verifyCredential.bind(this),
            verifyPresentation: this.verifyPresentation.bind(this),
        };
    }
    /** {@inheritdoc @veramo/core#ICredentialIssuer.createVerifiablePresentation} */
    createVerifiablePresentation(args, context) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let { presentation, proofFormat, domain, challenge, removeOriginalFields, keyRef, save, now } = args, otherOptions = __rest(args, ["presentation", "proofFormat", "domain", "challenge", "removeOriginalFields", "keyRef", "save", "now"]);
            const presentationContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.presentation) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const presentationType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.presentation) === null || _b === void 0 ? void 0 : _b.type, 'VerifiablePresentation');
            presentation = Object.assign(Object.assign({}, presentation), { '@context': presentationContext, type: presentationType });
            if (!(0, utils_1.isDefined)(presentation.holder)) {
                throw new Error('invalid_argument: presentation.holder must not be empty');
            }
            if (presentation.verifiableCredential) {
                presentation.verifiableCredential = presentation.verifiableCredential.map((cred) => {
                    // map JWT credentials to their canonical form
                    if (typeof cred !== 'string' && cred.proof.jwt) {
                        return cred.proof.jwt;
                    }
                    else {
                        return cred;
                    }
                });
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: presentation.holder });
            }
            catch (e) {
                throw new Error('invalid_argument: presentation.holder must be a DID managed by this agent');
            }
            //FIXME: `args` should allow picking a key or key type
            const key = identifier.keys.find((k) => k.type === 'Secp256k1' || k.type === 'Ed25519');
            if (!key)
                throw Error('key_not_found: No signing key for ' + identifier.did);
            let verifiablePresentation;
            if (proofFormat === 'lds') {
                if (typeof context.agent.createVerifiablePresentationLD === 'function') {
                    verifiablePresentation = yield context.agent.createVerifiablePresentationLD(Object.assign(Object.assign({}, args), { presentation }));
                }
                else {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerLD plugin installed');
                }
            }
            else if (proofFormat === 'EthereumEip712Signature2021') {
                if (typeof context.agent.createVerifiablePresentationEIP712 === 'function') {
                    verifiablePresentation = yield context.agent.createVerifiablePresentationEIP712(Object.assign(Object.assign({}, args), { presentation }));
                }
                else {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerEIP712 plugin installed');
                }
            }
            else {
                // only add issuanceDate for JWT
                now = typeof now === 'number' ? new Date(now * 1000) : now;
                if (!Object.getOwnPropertyNames(presentation).includes('issuanceDate')) {
                    presentation.issuanceDate = (now instanceof Date ? now : new Date()).toISOString();
                }
                debug('Signing VP with', identifier.did);
                let alg = 'ES256K';
                if (key.type === 'Ed25519') {
                    alg = 'EdDSA';
                }
                const signer = wrapSigner(context, key, alg);
                const jwt = yield (0, did_jwt_vc_1.createVerifiablePresentationJwt)(presentation, { did: identifier.did, signer, alg }, Object.assign({ removeOriginalFields, challenge, domain }, otherOptions));
                //FIXME: flagging this as a potential privacy leak.
                debug(jwt);
                verifiablePresentation = (0, did_jwt_vc_1.normalizePresentation)(jwt);
            }
            if (save) {
                yield context.agent.dataStoreSaveVerifiablePresentation({ verifiablePresentation });
            }
            return verifiablePresentation;
        });
    }
    /** {@inheritdoc @veramo/core#ICredentialIssuer.createVerifiableCredential} */
    createVerifiableCredential(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let { credential, proofFormat, keyRef, removeOriginalFields, save, now } = args, otherOptions = __rest(args, ["credential", "proofFormat", "keyRef", "removeOriginalFields", "save", "now"]);
            const credentialContext = (0, utils_1.processEntryToArray)(credential['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const credentialType = (0, utils_1.processEntryToArray)(credential.type, 'VerifiableCredential');
            // only add issuanceDate for JWT
            now = typeof now === 'number' ? new Date(now * 1000) : now;
            if (!Object.getOwnPropertyNames(credential).includes('issuanceDate')) {
                credential.issuanceDate = (now instanceof Date ? now : new Date()).toISOString();
            }
            credential = Object.assign(Object.assign({}, credential), { '@context': credentialContext, type: credentialType });
            //FIXME: if the identifier is not found, the error message should reflect that.
            const issuer = (0, utils_1.extractIssuer)(credential);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: credential.issuer must not be empty');
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: issuer });
            }
            catch (e) {
                throw new Error(`invalid_argument: credential.issuer must be a DID managed by this agent. ${e}`);
            }
            try {
                let verifiableCredential;
                if (proofFormat === 'lds') {
                    if (typeof context.agent.createVerifiableCredentialLD === 'function') {
                        verifiableCredential = yield context.agent.createVerifiableCredentialLD(Object.assign(Object.assign({}, args), { credential }));
                    }
                    else {
                        throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerLD plugin installed');
                    }
                }
                else if (proofFormat === 'EthereumEip712Signature2021') {
                    if (typeof context.agent.createVerifiableCredentialEIP712 === 'function') {
                        verifiableCredential = yield context.agent.createVerifiableCredentialEIP712(Object.assign(Object.assign({}, args), { credential }));
                    }
                    else {
                        throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerEIP712 plugin installed');
                    }
                }
                else {
                    //FIXME: `args` should allow picking a key or key type
                    const key = identifier.keys.find((k) => k.type === 'Secp256k1' || k.type === 'Ed25519');
                    if (!key)
                        throw Error('No signing key for ' + identifier.did);
                    debug('Signing VC with', identifier.did);
                    let alg = 'ES256K';
                    if (key.type === 'Ed25519') {
                        alg = 'EdDSA';
                    }
                    const signer = wrapSigner(context, key, alg);
                    const jwt = yield (0, did_jwt_vc_1.createVerifiableCredentialJwt)(credential, { did: identifier.did, signer, alg }, Object.assign({ removeOriginalFields }, otherOptions));
                    //FIXME: flagging this as a potential privacy leak.
                    debug(jwt);
                    verifiableCredential = (0, did_jwt_vc_1.normalizeCredential)(jwt);
                }
                if (save) {
                    yield context.agent.dataStoreSaveVerifiableCredential({ verifiableCredential });
                }
                return verifiableCredential;
            }
            catch (error) {
                debug(error);
                return Promise.reject(error);
            }
        });
    }
    /** {@inheritdoc @veramo/core#ICredentialVerifier.verifyCredential} */
    verifyCredential(args, context) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let { credential, policies } = args, otherOptions = __rest(args, ["credential", "policies"]);
            let verifiedCredential;
            let verificationResult = { verified: false };
            const type = detectDocumentType(credential);
            if (type == 0 /* DocumentFormat.JWT */) {
                let jwt = typeof credential === 'string' ? credential : credential.proof.jwt;
                const resolver = { resolve: (didUrl) => context.agent.resolveDid({ didUrl }) };
                try {
                    // needs broader credential as well to check equivalence with jwt
                    verificationResult = yield (0, did_jwt_vc_1.verifyCredential)(jwt, resolver, Object.assign(Object.assign({}, otherOptions), { policies: Object.assign(Object.assign({}, policies), { nbf: (_a = policies === null || policies === void 0 ? void 0 : policies.nbf) !== null && _a !== void 0 ? _a : policies === null || policies === void 0 ? void 0 : policies.issuanceDate, iat: (_b = policies === null || policies === void 0 ? void 0 : policies.iat) !== null && _b !== void 0 ? _b : policies === null || policies === void 0 ? void 0 : policies.issuanceDate, exp: (_c = policies === null || policies === void 0 ? void 0 : policies.exp) !== null && _c !== void 0 ? _c : policies === null || policies === void 0 ? void 0 : policies.expirationDate, aud: (_d = policies === null || policies === void 0 ? void 0 : policies.aud) !== null && _d !== void 0 ? _d : policies === null || policies === void 0 ? void 0 : policies.audience }) }));
                    verifiedCredential = verificationResult.verifiableCredential;
                    // if credential was presented with other fields, make sure those fields match what's in the JWT
                    if (typeof credential !== 'string') {
                        const credentialCopy = JSON.parse(JSON.stringify(credential));
                        delete credentialCopy.proof.jwt;
                        const verifiedCopy = JSON.parse(JSON.stringify(verifiedCredential));
                        delete verifiedCopy.proof.jwt;
                        if ((0, canonicalize_1.default)(credentialCopy) !== (0, canonicalize_1.default)(verifiedCopy)) {
                            verificationResult.verified = false;
                            verificationResult.error = new Error('Credential does not match JWT');
                        }
                    }
                }
                catch (e) {
                    let { message, errorCode } = e;
                    return {
                        verified: false,
                        error: {
                            message,
                            errorCode: errorCode ? errorCode : message.split(':')[0],
                        },
                    };
                }
            }
            else if (type == 2 /* DocumentFormat.EIP712 */) {
                if (typeof context.agent.verifyCredentialEIP712 !== 'function') {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerEIP712 plugin installed');
                }
                try {
                    const result = yield context.agent.verifyCredentialEIP712(args);
                    if (result) {
                        verificationResult = {
                            verified: true,
                        };
                    }
                    else {
                        verificationResult = {
                            verified: false,
                            error: {
                                message: 'invalid_signature: The signature does not match any of the issuer signing keys',
                                errorCode: 'invalid_signature',
                            },
                        };
                    }
                    verifiedCredential = credential;
                }
                catch (e) {
                    const { message, errorCode } = e;
                    return {
                        verified: false,
                        error: {
                            message,
                            errorCode: errorCode ? errorCode : e.message.split(':')[0],
                        },
                    };
                }
            }
            else if (type == 1 /* DocumentFormat.JSONLD */) {
                if (typeof context.agent.verifyCredentialLD !== 'function') {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerLD plugin installed');
                }
                verificationResult = yield context.agent.verifyCredentialLD(Object.assign(Object.assign({}, args), { now: policies === null || policies === void 0 ? void 0 : policies.now }));
                verifiedCredential = credential;
            }
            else {
                throw new Error('invalid_argument: Unknown credential type.');
            }
            if ((policies === null || policies === void 0 ? void 0 : policies.credentialStatus) !== false && (yield isRevoked(verifiedCredential, context))) {
                verificationResult = {
                    verified: false,
                    error: {
                        message: 'revoked: The credential was revoked by the issuer',
                        errorCode: 'revoked',
                    },
                };
            }
            return verificationResult;
        });
    }
    /** {@inheritdoc @veramo/core#ICredentialVerifier.verifyPresentation} */
    verifyPresentation(args, context) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let { presentation, domain, challenge, fetchRemoteContexts, policies } = args, otherOptions = __rest(args, ["presentation", "domain", "challenge", "fetchRemoteContexts", "policies"]);
            const type = detectDocumentType(presentation);
            if (type === 0 /* DocumentFormat.JWT */) {
                // JWT
                let jwt;
                if (typeof presentation === 'string') {
                    jwt = presentation;
                }
                else {
                    jwt = presentation.proof.jwt;
                }
                const resolver = { resolve: (didUrl) => context.agent.resolveDid({ didUrl }) };
                let audience = domain;
                if (!audience) {
                    const { payload } = yield (0, did_jwt_1.decodeJWT)(jwt);
                    if (payload.aud) {
                        // automatically add a managed DID as audience if one is found
                        const intendedAudience = (0, utils_1.asArray)(payload.aud);
                        const managedDids = yield context.agent.didManagerFind();
                        const filtered = managedDids.filter((identifier) => intendedAudience.includes(identifier.did));
                        if (filtered.length > 0) {
                            audience = filtered[0].did;
                        }
                    }
                }
                try {
                    return yield (0, did_jwt_vc_1.verifyPresentation)(jwt, resolver, Object.assign({ challenge,
                        domain,
                        audience, policies: Object.assign(Object.assign({}, policies), { nbf: (_a = policies === null || policies === void 0 ? void 0 : policies.nbf) !== null && _a !== void 0 ? _a : policies === null || policies === void 0 ? void 0 : policies.issuanceDate, iat: (_b = policies === null || policies === void 0 ? void 0 : policies.iat) !== null && _b !== void 0 ? _b : policies === null || policies === void 0 ? void 0 : policies.issuanceDate, exp: (_c = policies === null || policies === void 0 ? void 0 : policies.exp) !== null && _c !== void 0 ? _c : policies === null || policies === void 0 ? void 0 : policies.expirationDate, aud: (_d = policies === null || policies === void 0 ? void 0 : policies.aud) !== null && _d !== void 0 ? _d : policies === null || policies === void 0 ? void 0 : policies.audience }) }, otherOptions));
                }
                catch (e) {
                    let { message, errorCode } = e;
                    return {
                        verified: false,
                        error: {
                            message,
                            errorCode: errorCode ? errorCode : message.split(':')[0],
                        },
                    };
                }
            }
            else if (type === 2 /* DocumentFormat.EIP712 */) {
                // JSON-LD
                if (typeof context.agent.verifyPresentationEIP712 !== 'function') {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerEIP712 plugin installed');
                }
                try {
                    const result = yield context.agent.verifyPresentationEIP712(args);
                    if (result) {
                        return {
                            verified: true,
                        };
                    }
                    else {
                        return {
                            verified: false,
                            error: {
                                message: 'invalid_signature: The signature does not match any of the issuer signing keys',
                                errorCode: 'invalid_signature',
                            },
                        };
                    }
                }
                catch (e) {
                    const { message, errorCode } = e;
                    return {
                        verified: false,
                        error: {
                            message,
                            errorCode: errorCode ? errorCode : e.message.split(':')[0],
                        },
                    };
                }
            }
            else {
                // JSON-LD
                if (typeof context.agent.verifyPresentationLD === 'function') {
                    const result = yield context.agent.verifyPresentationLD(Object.assign(Object.assign({}, args), { now: policies === null || policies === void 0 ? void 0 : policies.now }));
                    return result;
                }
                else {
                    throw new Error('invalid_setup: your agent does not seem to have ICredentialIssuerLD plugin installed');
                }
            }
        });
    }
}
exports.CredentialPlugin = CredentialPlugin;
function wrapSigner(context, key, algorithm) {
    return (data) => __awaiter(this, void 0, void 0, function* () {
        const result = yield context.agent.keyManagerSign({ keyRef: key.kid, data: data, algorithm });
        return result;
    });
}
function detectDocumentType(document) {
    var _a, _b;
    if (typeof document === 'string' || ((_a = document === null || document === void 0 ? void 0 : document.proof) === null || _a === void 0 ? void 0 : _a.jwt))
        return 0 /* DocumentFormat.JWT */;
    if (((_b = document === null || document === void 0 ? void 0 : document.proof) === null || _b === void 0 ? void 0 : _b.type) === 'EthereumEip712Signature2021')
        return 2 /* DocumentFormat.EIP712 */;
    return 1 /* DocumentFormat.JSONLD */;
}
function isRevoked(credential, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!credential.credentialStatus)
            return false;
        if (typeof context.agent.checkCredentialStatus === 'function') {
            const status = yield context.agent.checkCredentialStatus({ credential });
            return (status === null || status === void 0 ? void 0 : status.revoked) == true || (status === null || status === void 0 ? void 0 : status.verified) === false;
        }
        throw new Error(`invalid_setup: The credential status can't be verified because there is no ICredentialStatusVerifier plugin installed.`);
    });
}
//# sourceMappingURL=action-handler.js.map