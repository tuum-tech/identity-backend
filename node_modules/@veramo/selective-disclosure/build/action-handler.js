"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectiveDisclosure = void 0;
const _1 = require("./");
const did_jwt_1 = require("did-jwt");
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("@veramo/utils");
/**
 * This class adds support for creating
 * {@link https://github.com/uport-project/specs/blob/develop/flows/selectivedisclosure.md | Selective Disclosure}
 * requests and interpret the responses received.
 *
 * This implementation of the uPort protocol uses
 * {@link https://www.w3.org/TR/vc-data-model/#presentations | W3C Presentation}
 * as the response encoding instead of a `shareReq`.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class SelectiveDisclosure {
    constructor() {
        this.schema = _1.schema.ISelectiveDisclosure;
        this.methods = {
            createSelectiveDisclosureRequest: this.createSelectiveDisclosureRequest,
            getVerifiableCredentialsForSdr: this.getVerifiableCredentialsForSdr,
            validatePresentationAgainstSdr: this.validatePresentationAgainstSdr,
            createProfilePresentation: this.createProfilePresentation,
        };
    }
    /**
     * Creates a Selective disclosure request, encoded as a JWT.
     *
     * @remarks See
     *   {@link https://github.com/uport-project/specs/blob/develop/flows/selectivedisclosure.md | Selective Disclosure}
     *
     * @param args - The param object with the properties necessary to create the request. See
     *   {@link ISelectiveDisclosureRequest}
     * @param context - *RESERVED* This is filled by the framework when the method is called.
     *
     * @beta This API may change without a BREAKING CHANGE notice.
     */
    createSelectiveDisclosureRequest(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const identifier = yield context.agent.didManagerGet({ did: args.data.issuer });
                const data = args.data;
                delete data.issuer;
                (0, debug_1.default)('veramo:selective-disclosure:create-sdr')('Signing SDR with', identifier.did);
                const key = identifier.keys.find((k) => k.type === 'Secp256k1');
                if (!key)
                    throw Error('Signing key not found');
                const signer = (data) => {
                    let dataString, encoding;
                    if (typeof data === 'string') {
                        dataString = data;
                        encoding = undefined;
                    }
                    else {
                        ;
                        (dataString = (0, utils_1.bytesToBase64)(data)), (encoding = 'base64');
                    }
                    return context.agent.keyManagerSign({ keyRef: key.kid, data: dataString, encoding });
                };
                const jwt = yield (0, did_jwt_1.createJWT)(Object.assign({ type: 'sdr' }, data), {
                    signer,
                    alg: 'ES256K',
                    issuer: identifier.did,
                });
                return jwt;
            }
            catch (error) {
                return Promise.reject(error);
            }
        });
    }
    /**
     * Gathers the required credentials necessary to fulfill a Selective Disclosure Request.
     * It uses a {@link @veramo/core#IDataStoreORM} plugin implementation to query the local database for
     * the required credentials.
     *
     * @param args - Contains the Request to be fulfilled and the DID of the subject
     * @param context - *RESERVED* This is filled by the framework when the method is called.
     *
     * @beta This API may change without a BREAKING CHANGE notice.
     */
    getVerifiableCredentialsForSdr(args, context) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const findArgs = { where: [] };
            for (const credentialRequest of args.sdr.claims) {
                if (credentialRequest.claimType) {
                    (_a = findArgs.where) === null || _a === void 0 ? void 0 : _a.push({ column: 'type', value: [credentialRequest.claimType] });
                }
                if (credentialRequest.claimValue) {
                    (_b = findArgs.where) === null || _b === void 0 ? void 0 : _b.push({ column: 'value', value: [credentialRequest.claimValue] });
                }
                if (credentialRequest.issuers && credentialRequest.issuers.length > 0) {
                    (_c = findArgs.where) === null || _c === void 0 ? void 0 : _c.push({ column: 'issuer', value: credentialRequest.issuers.map((i) => i.did) });
                }
                if (credentialRequest.credentialType) {
                    (_d = findArgs.where) === null || _d === void 0 ? void 0 : _d.push({
                        column: 'credentialType',
                        value: ['%' + credentialRequest.credentialType + '%'],
                        op: 'Like',
                    });
                }
                if (credentialRequest.credentialContext) {
                    (_e = findArgs.where) === null || _e === void 0 ? void 0 : _e.push({
                        column: 'context',
                        value: ['%' + credentialRequest.credentialContext + '%'],
                        op: 'Like',
                    });
                }
                if (args.did || args.sdr.subject) {
                    (_f = findArgs.where) === null || _f === void 0 ? void 0 : _f.push({ column: 'subject', value: ['' + (args.did || args.sdr.subject)] });
                }
                const credentials = yield context.agent.dataStoreORMGetVerifiableCredentialsByClaims(findArgs);
                result.push(Object.assign(Object.assign({}, credentialRequest), { credentials }));
            }
            return result;
        });
    }
    /**
     * Validates a
     * {@link https://github.com/uport-project/specs/blob/develop/flows/selectivedisclosure.md | Selective Disclosure response} encoded as a `Presentation`
     *
     * @param args - Contains the request and the response `Presentation` that needs to be checked.
     * @param context - *RESERVED* This is filled by the framework when the method is called.
     *
     * @beta This API may change without a BREAKING CHANGE notice.
     */
    validatePresentationAgainstSdr(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let valid = true;
            let claims = [];
            for (const credentialRequest of args.sdr.claims) {
                let credentials = (((_a = args.presentation) === null || _a === void 0 ? void 0 : _a.verifiableCredential) || [])
                    .map(utils_1.decodeCredentialToObject)
                    .filter((credential) => {
                    if (credentialRequest.claimType &&
                        credentialRequest.claimValue &&
                        credential.credentialSubject[credentialRequest.claimType] !== credentialRequest.claimValue) {
                        return false;
                    }
                    if (credentialRequest.claimType &&
                        !credentialRequest.claimValue &&
                        credential.credentialSubject[credentialRequest.claimType] === undefined) {
                        return false;
                    }
                    if (credentialRequest.issuers &&
                        !credentialRequest.issuers.map((i) => i.did).includes((0, utils_1.extractIssuer)(credential))) {
                        return false;
                    }
                    if (credentialRequest.credentialContext &&
                        !(0, utils_1.asArray)(credential['@context'] || []).includes(credentialRequest.credentialContext)) {
                        return false;
                    }
                    if (credentialRequest.credentialType &&
                        !(0, utils_1.asArray)(credential.type || []).includes(credentialRequest.credentialType)) {
                        return false;
                    }
                    return true;
                });
                if (credentialRequest.essential === true && credentials.length == 0) {
                    valid = false;
                }
                claims.push(Object.assign(Object.assign({}, credentialRequest), { credentials: credentials.map((vc) => ({
                        hash: (0, utils_1.computeEntryHash)(vc),
                        verifiableCredential: vc,
                    })) }));
            }
            return { valid, claims };
        });
    }
    /**
     * Creates profile credentials
     *
     * @beta This API may change without a BREAKING CHANGE notice.
     */
    createProfilePresentation(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const identifier = yield context.agent.didManagerGet({ did: args.holder });
            const credentials = [];
            if (args.name) {
                const credential = yield context.agent.createVerifiableCredential({
                    credential: {
                        issuer: { id: identifier.did },
                        '@context': ['https://www.w3.org/2018/credentials/v1'],
                        type: ['VerifiableCredential', 'Profile'],
                        issuanceDate: new Date().toISOString(),
                        credentialSubject: {
                            id: identifier.did,
                            name: args.name,
                        },
                    },
                    proofFormat: 'jwt',
                });
                credentials.push(credential);
            }
            if (args.picture) {
                const credential = yield context.agent.createVerifiableCredential({
                    credential: {
                        issuer: { id: identifier.did },
                        type: ['Profile'],
                        credentialSubject: {
                            id: identifier.did,
                            picture: args.picture,
                        },
                    },
                    proofFormat: 'jwt',
                });
                credentials.push(credential);
            }
            if (args.url) {
                const credential = yield context.agent.createVerifiableCredential({
                    credential: {
                        issuer: { id: identifier.did },
                        type: ['Profile'],
                        credentialSubject: {
                            id: identifier.did,
                            url: args.url,
                        },
                    },
                    proofFormat: 'jwt',
                });
                credentials.push(credential);
            }
            const profile = yield context.agent.createVerifiablePresentation({
                presentation: {
                    verifier: args.holder ? [args.holder] : [],
                    holder: identifier.did,
                    type: ['Profile'],
                    verifiableCredential: credentials,
                },
                proofFormat: 'jwt',
                save: args.save,
            });
            if (args.verifier && args.send) {
                yield context.agent.sendMessageDIDCommAlpha1({
                    save: args.save,
                    data: {
                        from: identifier.did,
                        to: args.verifier,
                        type: 'jwt',
                        body: profile.proof.jwt,
                    },
                });
            }
            return profile;
        });
    }
}
exports.SelectiveDisclosure = SelectiveDisclosure;
//# sourceMappingURL=action-handler.js.map