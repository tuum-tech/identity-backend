"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDCommHttpTransport = exports.AbstractDIDCommTransport = void 0;
require("cross-fetch/polyfill");
const uuid_1 = require("uuid");
/**
 * Abstract implementation of {@link IDIDCommTransport}.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class AbstractDIDCommTransport {
    /**
     * Shared constructor that takes an optional identifier (for reusing) for
     * this {@link IDIDCommTransport}.
     *
     * @param id - An optional identifier for this {@link IDIDCommTransport}.
     *
     * @beta This API may change without a BREAKING CHANGE notice.
     */
    constructor(id) {
        this.id = id || (0, uuid_1.v4)();
    }
}
exports.AbstractDIDCommTransport = AbstractDIDCommTransport;
/**
 * Implementation of {@link IDIDCommTransport} to provide a simple
 * transport based on HTTP(S) requests.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class DIDCommHttpTransport extends AbstractDIDCommTransport {
    /**
     * Creates a new {@link DIDCommHttpTransport}.
     * @param httpMethod - Default HTTP method if not specified in the service
     * section.
     */
    constructor(httpMethod) {
        super();
        this.httpMethod = httpMethod || 'post';
    }
    /** {@inheritdoc AbstractDIDCommTransport.isServiceSupported} */
    isServiceSupported(service) {
        // serviceEndpoint can be a string, a ServiceEndpoint object, or an array of strings or ServiceEndpoint objects
        return ((typeof service.serviceEndpoint === 'string' && (service.serviceEndpoint.startsWith('http://') || service.serviceEndpoint.startsWith('https://')))
            ||
                (service.serviceEndpoint.uri && typeof service.serviceEndpoint.uri === 'string' && (service.serviceEndpoint.uri.startsWith('http://') || service.serviceEndpoint.uri.startsWith('https://')))
            ||
                (service.serviceEndpoint.length > 0 && typeof service.serviceEndpoint[0] === 'string' && (service.serviceEndpoint[0].startsWith('http://') || service.serviceEndpoint[0].startsWith('https://')))
            ||
                (service.serviceEndpoint.length > 0 && typeof service.serviceEndpoint[0].uri === 'string' && (service.serviceEndpoint[0].uri.startsWith('http://') || service.serviceEndpoint[0].uri.startsWith('https://'))));
    }
    /** {@inheritdoc AbstractDIDCommTransport.send} */
    send(service, message) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceEndpointUrl = '';
            if (typeof service.serviceEndpoint === 'string') {
                serviceEndpointUrl = service.serviceEndpoint;
            }
            else if (service.serviceEndpoint.uri) {
                serviceEndpointUrl = service.serviceEndpoint.uri;
            }
            else if (service.serviceEndpoint.length > 0) {
                if (typeof service.serviceEndpoint[0] === 'string') {
                    serviceEndpointUrl = service.serviceEndpoint[0];
                }
                else if (service.serviceEndpoint[0].uri) {
                    serviceEndpointUrl = service.serviceEndpoint[0].uri;
                }
            }
            try {
                const response = yield fetch(serviceEndpointUrl, {
                    method: this.httpMethod,
                    body: message,
                });
                let result;
                if (response.ok) {
                    result = {
                        result: 'successfully sent message: ' + response.statusText,
                    };
                }
                else {
                    result = {
                        error: 'failed to send message: ' + response.statusText,
                    };
                }
                return result;
            }
            catch (e) {
                return {
                    error: 'failed to send message: ' + e,
                };
            }
        });
    }
}
exports.DIDCommHttpTransport = DIDCommHttpTransport;
//# sourceMappingURL=transports.js.map