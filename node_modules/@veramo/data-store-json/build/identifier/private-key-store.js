"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyStoreJson = void 0;
const key_manager_1 = require("@veramo/key-manager");
const uuid_1 = require("uuid");
const debug_1 = __importDefault(require("debug"));
const structured_clone_1 = require("@ungap/structured-clone");
const debug = (0, debug_1.default)('veramo:data-store-json:private-key-store');
/**
 * An implementation of {@link @veramo/key-manager#AbstractPrivateKeyStore | AbstractPrivateKeyStore} that uses a JSON
 * object to store the private key material needed by {@link @veramo/kms-local#KeyManagementSystem |
 * KeyManagementSystem}.
 *
 * This class must be initialized with a {@link VeramoJsonStore}, which serves as the JSON object storing data in
 * memory as well as providing an update notification callback to persist this data.
 * The JSON object does not have to be shared with other users of {@link VeramoJsonStore}, but it can be.
 *
 * If an {@link @veramo/key-manager#AbstractSecretBox | AbstractSecretBox} is used, then key material is encrypted,
 * even in memory.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class PrivateKeyStoreJson extends key_manager_1.AbstractPrivateKeyStore {
    /**
     * @param jsonStore - This serves as the JSON object storing data in memory as well as providing an update notification
     *   callback to persist this data. The JSON object does not have to be shared with other users of
     *   {@link VeramoJsonStore}, but it can be.
     * @param secretBox - If this is used, then key material is encrypted, even in memory.
     */
    constructor(jsonStore, secretBox) {
        super();
        this.secretBox = secretBox;
        this.cacheTree = jsonStore;
        this.notifyUpdate = jsonStore.notifyUpdate;
        if (!this.cacheTree.privateKeys) {
            this.cacheTree.privateKeys = {};
        }
        if (!secretBox) {
            console.warn('Please provide SecretBox to the KeyStore');
        }
    }
    get({ alias }) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree.privateKeys[alias]));
            if (!key)
                throw Error('not_found: PrivateKey not found');
            if (this.secretBox && key.privateKeyHex) {
                key.privateKeyHex = yield this.secretBox.decrypt(key.privateKeyHex);
            }
            return key;
        });
    }
    delete({ alias }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Deleting private key data for alias=${alias}`);
            const privateKeyEntry = this.cacheTree.privateKeys[alias];
            if (privateKeyEntry) {
                const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
                delete this.cacheTree.privateKeys[alias];
                yield this.notifyUpdate(oldTree, this.cacheTree);
            }
            return true;
        });
    }
    import(args) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Saving private key data', args.alias);
            const alias = args.alias || (0, uuid_1.v4)();
            const key = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(Object.assign(Object.assign({}, args), { alias })));
            if (this.secretBox && key.privateKeyHex) {
                const copy = key.privateKeyHex;
                key.privateKeyHex = yield this.secretBox.encrypt(copy);
            }
            const existingKey = this.cacheTree.privateKeys[key.alias];
            if (existingKey && existingKey.privateKeyHex !== key.privateKeyHex) {
                throw new Error(`key_already_exists: A key with this alias exists but with different data. Please use a different alias.`);
            }
            const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
            this.cacheTree.privateKeys[key.alias] = key;
            yield this.notifyUpdate(oldTree, this.cacheTree);
            return key;
        });
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(Object.values(this.cacheTree.privateKeys)));
        });
    }
}
exports.PrivateKeyStoreJson = PrivateKeyStoreJson;
//# sourceMappingURL=private-key-store.js.map