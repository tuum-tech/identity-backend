"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreJson = void 0;
const core_1 = require("@veramo/core");
const utils_1 = require("@veramo/utils");
const structured_clone_1 = require("@ungap/structured-clone");
const did_jwt_vc_1 = require("did-jwt-vc");
/**
 * A Veramo agent storage plugin that implements the {@link @veramo/core#IDataStore | IDataStore} and
 * {@link @veramo/core#IDataStoreORM | IDataStoreORM} methods using one big JSON object as a backend.
 *
 * Each update operation triggers a callback that can be used to either save the latest state of the agent data or
 * compute a diff and log only the changes.
 *
 * This plugin must be initialized with a {@link VeramoJsonStore}, which serves as the JSON object storing data in
 * memory as well as providing an update notification callback to persist this data.
 * The JSON object can be pre-populated with data from previous sessions.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class DataStoreJson {
    /**
     * @param jsonStore - A reference to the JSON object that holds the data in memory and implements an update callback.
     *   This object can be pre-populated with data from previous sessions, and will be used by reference.
     */
    constructor(jsonStore) {
        this.schema = Object.assign(Object.assign({}, core_1.schema.IDataStore), core_1.schema.IDataStoreORM);
        this.notifyUpdate = jsonStore.notifyUpdate;
        this.cacheTree = jsonStore;
        const tables = ['dids', 'credentials', 'presentations', 'claims', 'messages'];
        for (const table of tables) {
            if (!this.cacheTree[table]) {
                this.cacheTree[table] = {};
            }
        }
        this.methods = {
            // IDataStore methods
            dataStoreSaveMessage: this.dataStoreSaveMessage.bind(this),
            dataStoreGetMessage: this.dataStoreGetMessage.bind(this),
            //dataStoreDeleteMessage: this.dataStoreDeleteMessage.bind(this),
            dataStoreSaveVerifiableCredential: this.dataStoreSaveVerifiableCredential.bind(this),
            dataStoreGetVerifiableCredential: this.dataStoreGetVerifiableCredential.bind(this),
            dataStoreDeleteVerifiableCredential: this.dataStoreDeleteVerifiableCredential.bind(this),
            dataStoreSaveVerifiablePresentation: this.dataStoreSaveVerifiablePresentation.bind(this),
            dataStoreGetVerifiablePresentation: this.dataStoreGetVerifiablePresentation.bind(this),
            //dataStoreDeleteVerifiablePresentation: this.dataStoreDeleteVerifiablePresentation.bind(this),
            // IDataStoreORM methods
            dataStoreORMGetIdentifiers: this.dataStoreORMGetIdentifiers.bind(this),
            dataStoreORMGetIdentifiersCount: this.dataStoreORMGetIdentifiersCount.bind(this),
            dataStoreORMGetMessages: this.dataStoreORMGetMessages.bind(this),
            dataStoreORMGetMessagesCount: this.dataStoreORMGetMessagesCount.bind(this),
            dataStoreORMGetVerifiableCredentialsByClaims: this.dataStoreORMGetVerifiableCredentialsByClaims.bind(this),
            dataStoreORMGetVerifiableCredentialsByClaimsCount: this.dataStoreORMGetVerifiableCredentialsByClaimsCount.bind(this),
            dataStoreORMGetVerifiableCredentials: this.dataStoreORMGetVerifiableCredentials.bind(this),
            dataStoreORMGetVerifiableCredentialsCount: this.dataStoreORMGetVerifiableCredentialsCount.bind(this),
            dataStoreORMGetVerifiablePresentations: this.dataStoreORMGetVerifiablePresentations.bind(this),
            dataStoreORMGetVerifiablePresentationsCount: this.dataStoreORMGetVerifiablePresentationsCount.bind(this),
        };
    }
    dataStoreSaveMessage(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const id = ((_a = args.message) === null || _a === void 0 ? void 0 : _a.id) || (0, utils_1.computeEntryHash)(args.message);
            const message = Object.assign(Object.assign({}, args.message), { id });
            const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
            this.cacheTree.messages[id] = message;
            // TODO: deprecate automatic credential and presentation saving
            const credentials = (0, utils_1.asArray)(message.credentials);
            const presentations = (0, utils_1.asArray)(message.presentations);
            for (const verifiableCredential of credentials) {
                yield this._dataStoreSaveVerifiableCredential({ verifiableCredential }, false);
            }
            for (const verifiablePresentation of presentations) {
                yield this._dataStoreSaveVerifiablePresentation({ verifiablePresentation }, false);
            }
            // adding dummy DIDs is required to make `dataStoreORMGetIdentifiers` work
            if ((message === null || message === void 0 ? void 0 : message.from) && !this.cacheTree.dids[message.from]) {
                this.cacheTree.dids[message.from] = { did: message.from, provider: '', keys: [], services: [] };
            }
            (0, utils_1.asArray)(message.to).forEach((did) => {
                if (!this.cacheTree.dids[did]) {
                    this.cacheTree.dids[did] = { did, provider: '', keys: [], services: [] };
                }
            });
            yield this.notifyUpdate(oldTree, this.cacheTree);
            return message.id;
        });
    }
    dataStoreGetMessage(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = this.cacheTree.messages[args.id];
            if (message) {
                return message;
            }
            else {
                throw Error('Message not found');
            }
        });
    }
    _dataStoreSaveVerifiableCredential(args, postUpdates = true) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const canonicalCredential = ((_b = (_a = args === null || args === void 0 ? void 0 : args.verifiableCredential) === null || _a === void 0 ? void 0 : _a.proof) === null || _b === void 0 ? void 0 : _b.type) === 'JwtProof2020' &&
                typeof ((_d = (_c = args === null || args === void 0 ? void 0 : args.verifiableCredential) === null || _c === void 0 ? void 0 : _c.proof) === null || _d === void 0 ? void 0 : _d.jwt) === 'string'
                ? (_f = (_e = args === null || args === void 0 ? void 0 : args.verifiableCredential) === null || _e === void 0 ? void 0 : _e.proof) === null || _f === void 0 ? void 0 : _f.jwt
                : args.verifiableCredential;
            const vc = args.verifiableCredential;
            const id = vc.id;
            const hash = (0, utils_1.computeEntryHash)(canonicalCredential);
            const issuer = (0, utils_1.extractIssuer)(vc);
            const subject = vc.credentialSubject.id;
            const context = (0, utils_1.asArray)(vc['@context']);
            const type = (0, utils_1.asArray)(vc.type);
            let issuanceDate = undefined;
            let expirationDate = undefined;
            if (vc.issuanceDate) {
                issuanceDate = new Date(vc.issuanceDate);
            }
            if (vc.expirationDate) {
                expirationDate = new Date(vc.expirationDate);
            }
            const credential = {
                hash,
                id,
                parsedCredential: vc,
                canonicalCredential,
                issuer,
                subject,
                issuanceDate,
                expirationDate,
                context,
                type,
            };
            const claims = [];
            for (const claimType in vc.credentialSubject) {
                if (vc.credentialSubject.hasOwnProperty(claimType)) {
                    const value = vc.credentialSubject[claimType];
                    if (claimType !== 'id') {
                        const claim = {
                            hash: (0, utils_1.computeEntryHash)(hash + claimType),
                            type: claimType,
                            value,
                            issuer,
                            subject,
                            issuanceDate,
                            expirationDate,
                            context: context,
                            credentialType: type,
                            credentialHash: hash,
                        };
                        claims.push(claim);
                    }
                }
            }
            let oldTree;
            if (postUpdates) {
                oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
            }
            this.cacheTree.credentials[hash] = credential;
            for (const claim of claims) {
                this.cacheTree.claims[claim.hash] = claim;
            }
            // adding dummy DIDs is required to make `dataStoreORMGetIdentifiers` work
            if (issuer && !this.cacheTree.dids[issuer]) {
                this.cacheTree.dids[issuer] = { did: issuer, provider: '', keys: [], services: [] };
            }
            if (subject && !this.cacheTree.dids[subject]) {
                this.cacheTree.dids[subject] = { did: subject, provider: '', keys: [], services: [] };
            }
            if (postUpdates) {
                yield this.notifyUpdate(oldTree, this.cacheTree);
            }
            return credential.hash;
        });
    }
    dataStoreSaveVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._dataStoreSaveVerifiableCredential(args);
        });
    }
    dataStoreDeleteVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const credential = this.cacheTree.credentials[args.hash];
            if (credential) {
                const claims = Object.values(this.cacheTree.claims)
                    .filter((claim) => claim.credentialHash === credential.hash)
                    .map((claim) => claim.hash);
                const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
                delete this.cacheTree.credentials[args.hash];
                for (const claimHash of claims) {
                    delete this.cacheTree.claims[claimHash];
                }
                yield this.notifyUpdate(oldTree, this.cacheTree);
                return true;
            }
            return false;
        });
    }
    dataStoreGetVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialEntity = this.cacheTree.credentials[args.hash];
            if (credentialEntity) {
                const { parsedCredential } = credentialEntity;
                return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(parsedCredential));
            }
            else {
                throw Error('Verifiable credential not found');
            }
        });
    }
    _dataStoreSaveVerifiablePresentation(args, postUpdates = true) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const vp = args.verifiablePresentation;
            const canonicalPresentation = ((_a = vp === null || vp === void 0 ? void 0 : vp.proof) === null || _a === void 0 ? void 0 : _a.type) === 'JwtProof2020' && typeof ((_b = vp === null || vp === void 0 ? void 0 : vp.proof) === null || _b === void 0 ? void 0 : _b.jwt) === 'string' ? (_c = vp === null || vp === void 0 ? void 0 : vp.proof) === null || _c === void 0 ? void 0 : _c.jwt : vp;
            const id = vp.id;
            const hash = (0, utils_1.computeEntryHash)(canonicalPresentation);
            const holder = (0, utils_1.extractIssuer)(vp);
            const verifier = (0, utils_1.asArray)(vp.verifier);
            const context = (0, utils_1.asArray)(vp['@context']);
            const type = (0, utils_1.asArray)(vp.type);
            let issuanceDate = undefined;
            let expirationDate = undefined;
            if (vp.issuanceDate) {
                issuanceDate = new Date(vp.issuanceDate);
            }
            if (vp.expirationDate) {
                expirationDate = new Date(vp.expirationDate);
            }
            const credentials = (0, utils_1.asArray)(vp.verifiableCredential).map((cred) => {
                if (typeof cred === 'string') {
                    return (0, did_jwt_vc_1.normalizeCredential)(cred);
                }
                else {
                    return cred;
                }
            });
            const presentation = {
                hash,
                id,
                parsedPresentation: vp,
                canonicalPresentation,
                holder,
                verifier,
                issuanceDate,
                expirationDate,
                context,
                type,
                credentials,
            };
            let oldTree;
            if (postUpdates) {
                oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
            }
            this.cacheTree.presentations[hash] = presentation;
            for (const verifiableCredential of credentials) {
                yield this._dataStoreSaveVerifiableCredential({ verifiableCredential }, false);
            }
            // adding dummy DIDs is required to make `dataStoreORMGetIdentifiers` work
            if (holder && !this.cacheTree.dids[holder]) {
                this.cacheTree.dids[holder] = { did: holder, provider: '', keys: [], services: [] };
            }
            (0, utils_1.asArray)(verifier).forEach((did) => {
                if (!this.cacheTree.dids[did]) {
                    this.cacheTree.dids[did] = { did, provider: '', keys: [], services: [] };
                }
            });
            if (postUpdates) {
                yield this.notifyUpdate(oldTree, this.cacheTree);
            }
            return hash;
        });
    }
    dataStoreSaveVerifiablePresentation(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._dataStoreSaveVerifiablePresentation(args);
        });
    }
    dataStoreGetVerifiablePresentation(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const presentationEntry = this.cacheTree.presentations[args.hash];
            if (presentationEntry) {
                const { parsedPresentation } = presentationEntry;
                return parsedPresentation;
            }
            else {
                throw Error('Verifiable presentation not found');
            }
        });
    }
    dataStoreORMGetIdentifiers(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const identifiers = buildQuery(Object.values(this.cacheTree.dids), args, ['did'], context.authorizedDID);
            // FIXME: collect corresponding keys from `this.cacheTree.keys`?
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(identifiers));
        });
    }
    dataStoreORMGetIdentifiersCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.dataStoreORMGetIdentifiers(args, context)).length;
        });
    }
    dataStoreORMGetMessages(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = buildQuery(Object.values(this.cacheTree.messages), args, ['to', 'from'], context.authorizedDID);
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(messages));
        });
    }
    dataStoreORMGetMessagesCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.dataStoreORMGetMessages(args, context)).length;
        });
    }
    dataStoreORMGetVerifiableCredentialsByClaims(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const filteredClaims = buildQuery(Object.values(this.cacheTree.claims), args, ['issuer', 'subject'], context.authorizedDID);
            let filteredCredentials = new Set();
            filteredClaims.forEach((claim) => {
                filteredCredentials.add(this.cacheTree.credentials[claim.credentialHash]);
            });
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(Array.from(filteredCredentials).map((cred) => {
                const { hash, parsedCredential } = cred;
                return {
                    hash,
                    verifiableCredential: parsedCredential,
                };
            })));
        });
    }
    dataStoreORMGetVerifiableCredentialsByClaimsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.dataStoreORMGetVerifiableCredentialsByClaims(args, context)).length;
        });
    }
    dataStoreORMGetVerifiableCredentials(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentials = buildQuery(Object.values(this.cacheTree.credentials), args, ['issuer', 'subject'], context.authorizedDID);
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(credentials.map((cred) => {
                const { hash, parsedCredential } = cred;
                return {
                    hash,
                    verifiableCredential: parsedCredential,
                };
            })));
        });
    }
    dataStoreORMGetVerifiableCredentialsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.dataStoreORMGetVerifiableCredentials(args, context)).length;
        });
    }
    dataStoreORMGetVerifiablePresentations(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const presentations = buildQuery(Object.values(this.cacheTree.presentations), args, ['holder', 'verifier'], context.authorizedDID);
            return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(presentations.map((pres) => {
                const { hash, parsedPresentation } = pres;
                return {
                    hash,
                    verifiablePresentation: parsedPresentation,
                };
            })));
        });
    }
    dataStoreORMGetVerifiablePresentationsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.dataStoreORMGetVerifiablePresentations(args, context)).length;
        });
    }
}
exports.DataStoreJson = DataStoreJson;
function buildFilter(target, input) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let condition = true;
    if (input === null || input === void 0 ? void 0 : input.where) {
        for (const item of input.where) {
            let newCondition;
            const targetValue = target[item.column];
            switch (item.op) {
                case 'Between':
                    if (((_a = item.value) === null || _a === void 0 ? void 0 : _a.length) != 2)
                        throw Error('Operation Between requires two values');
                    newCondition = item.value[0] <= targetValue && targetValue <= item.value[1];
                    break;
                case 'Equal':
                    if (((_b = item.value) === null || _b === void 0 ? void 0 : _b.length) != 1)
                        throw Error('Operation Equal requires one value');
                    newCondition = item.value[0] === targetValue;
                    if (Array.isArray(targetValue)) {
                        // mimicking legacy SQL data-store behavior where array values are stored as joined strings
                        newCondition || (newCondition = targetValue.join(',').includes(item.value[0]));
                    }
                    break;
                case 'IsNull':
                    newCondition = targetValue === null || typeof targetValue === 'undefined';
                    break;
                case 'LessThan':
                    if (((_c = item.value) === null || _c === void 0 ? void 0 : _c.length) != 1)
                        throw Error('Operation LessThan requires one value');
                    newCondition = targetValue < item.value;
                    break;
                case 'LessThanOrEqual':
                    if (((_d = item.value) === null || _d === void 0 ? void 0 : _d.length) != 1)
                        throw Error('Operation LessThanOrEqual requires one value');
                    newCondition = targetValue <= item.value;
                    break;
                case 'Like':
                    if (((_e = item.value) === null || _e === void 0 ? void 0 : _e.length) != 1)
                        throw Error('Operation Like requires one value');
                    // FIXME: add support for escaping
                    const likeExpression = `^${(((_f = item.value) === null || _f === void 0 ? void 0 : _f[0]) || '').replace(/_/g, '.').replace(/%/g, '.*')}$`;
                    newCondition = new RegExp(likeExpression).test(targetValue);
                    break;
                case 'MoreThan':
                    if (((_g = item.value) === null || _g === void 0 ? void 0 : _g.length) != 1)
                        throw Error('Operation MoreThan requires one value');
                    newCondition = targetValue > item.value;
                    break;
                case 'MoreThanOrEqual':
                    if (((_h = item.value) === null || _h === void 0 ? void 0 : _h.length) != 1)
                        throw Error('Operation MoreThanOrEqual requires one value');
                    newCondition = targetValue >= item.value;
                    break;
                case 'Any':
                case 'In':
                default:
                    if (!Array.isArray(item.value))
                        throw Error('Operator Any requires value to be an array');
                    if (Array.isArray(targetValue)) {
                        newCondition = item.value.find((val) => targetValue.includes(val)) !== undefined;
                        // mimicking legacy SQL data-store behavior where array values are stored as joined strings
                        newCondition || (newCondition = targetValue.join(',').includes(item.value.join(',')));
                    }
                    else {
                        newCondition = item.value.includes(targetValue);
                    }
                    break;
            }
            if (item.not === true) {
                newCondition = !newCondition;
            }
            condition && (condition = newCondition);
        }
    }
    return condition;
}
function buildQuery(targetCollection, input, authFilterColumns, authFilterValue) {
    let filteredCollection = targetCollection.filter((target) => buildFilter(target, input));
    if (authFilterValue) {
        filteredCollection = filteredCollection.filter((target) => {
            let columnValues = [];
            for (const column of authFilterColumns) {
                columnValues = [...columnValues, ...(0, utils_1.asArray)(target[column])];
            }
            return columnValues.includes(authFilterValue);
        });
    }
    if (input.skip) {
        filteredCollection = filteredCollection.slice(input.skip);
    }
    if (input.take) {
        filteredCollection = filteredCollection.slice(0, input.take);
    }
    if (input.order && input.order.length > 0) {
        filteredCollection.sort((a, b) => {
            var _a, _b, _c, _d;
            let result = 0;
            let orderIndex = 0;
            while (result == 0 && ((_a = input.order) === null || _a === void 0 ? void 0 : _a[orderIndex])) {
                const direction = ((_b = input.order) === null || _b === void 0 ? void 0 : _b[orderIndex].direction) === 'DESC' ? -1 : 1;
                const col = (_d = (_c = input.order) === null || _c === void 0 ? void 0 : _c[orderIndex]) === null || _d === void 0 ? void 0 : _d.column;
                if (!col) {
                    break;
                }
                const colA = a[col];
                const colB = b[col];
                if (typeof (colA === null || colA === void 0 ? void 0 : colA.localeCompare) === 'function') {
                    result = direction * colA.localeCompare(colB);
                }
                else {
                    result = direction * (colA - colB || 0);
                }
                orderIndex++;
            }
            return result;
        });
    }
    return filteredCollection;
}
//# sourceMappingURL=data-store-json.js.map