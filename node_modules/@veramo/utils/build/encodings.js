"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.base58ToBytes = exports.bytesToHex = exports.hexToBytes = exports.decodeJoseBlob = exports.encodeJoseBlob = exports.decodeBase64url = exports.encodeBase64url = exports.bytesToBase64 = exports.base64ToBytes = exports.bytesToBase64url = void 0;
const u8a = __importStar(require("uint8arrays"));
/**
 * Converts a Uint8Array to a base64url string
 * @param b - the array to be converted
 *
 * @public
 */
function bytesToBase64url(b) {
    return u8a.toString(b, 'base64url');
}
exports.bytesToBase64url = bytesToBase64url;
/**
 * Converts a base64url string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function base64ToBytes(s) {
    const inputBase64Url = s.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    return u8a.fromString(inputBase64Url, 'base64url');
}
exports.base64ToBytes = base64ToBytes;
/**
 * Encodes a Uint8Array to a base64 string representation with padding.
 * @param b - the byte array to convert
 *
 * @public
 */
function bytesToBase64(b) {
    return u8a.toString(b, 'base64pad');
}
exports.bytesToBase64 = bytesToBase64;
/**
 * Encodes the bytes of an input string to base64url
 * @param s - the original string
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function encodeBase64url(s) {
    return bytesToBase64url(u8a.fromString(s));
}
exports.encodeBase64url = encodeBase64url;
/**
 * Decodes a base64url string to a utf8 string represented by the same bytes.
 * @param s - the base64url string to be decoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function decodeBase64url(s) {
    return u8a.toString(base64ToBytes(s));
}
exports.decodeBase64url = decodeBase64url;
/**
 * Stringifies a JSON object and encodes the bytes of the resulting string to a base64url representation.
 * @param payload - the object to be encoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function encodeJoseBlob(payload) {
    return u8a.toString(u8a.fromString(JSON.stringify(payload), 'utf-8'), 'base64url');
}
exports.encodeJoseBlob = encodeJoseBlob;
/**
 * Decodes a base64url string representing stringified JSON to a JSON object.
 *
 * @param blob - The base64url encoded stringified JSON to be decoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function decodeJoseBlob(blob) {
    return JSON.parse(u8a.toString(u8a.fromString(blob, 'base64url'), 'utf-8'));
}
exports.decodeJoseBlob = decodeJoseBlob;
/**
 * Converts a hex string (with or without prefix) to a byte array (Uint8Array)
 *
 * @param hexString - The string representing the encoding
 * @returns the `Uint8Array` represented by the given string
 *
 * @throws `illegal_argument` error if the parameter is not a string
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function hexToBytes(hexString) {
    // @ts-ignore
    if (hexString instanceof Uint8Array) {
        return Uint8Array.from(hexString);
    }
    if (typeof hexString !== 'string') {
        throw new Error('illegal_argument: a string must be provided for a hex-string to byte array conversion');
    }
    const noPrefix = hexString.startsWith('0x') ? hexString.substring(2) : hexString;
    const padded = noPrefix.length % 2 !== 0 ? `0${noPrefix}` : noPrefix;
    return u8a.fromString(padded.toLowerCase(), 'base16');
}
exports.hexToBytes = hexToBytes;
/**
 * Converts a Uint8Array input to a hex string
 *
 * @param byteArray - The array to be converted
 * @param prefix - If this is set to true, the resulting hex string will be prefixed with 0x
 *
 * @returns the hex encoding of the input byte array
 *
 * @throws `illegal_argument` error if the input is not a Uint8Array
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function bytesToHex(byteArray, prefix = false) {
    if (!(byteArray instanceof Uint8Array)) {
        throw new Error('illegal_argument: only byte arrays can be converted to hex encoding');
    }
    const result = u8a.toString(byteArray, 'base16');
    return prefix ? `0x${result}` : result;
}
exports.bytesToHex = bytesToHex;
/**
 * Converts a base58 string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function base58ToBytes(s) {
    return u8a.fromString(s, 'base58btc');
}
exports.base58ToBytes = base58ToBytes;
//# sourceMappingURL=encodings.js.map