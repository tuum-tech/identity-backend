"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStore = void 0;
const core_1 = require("@veramo/core");
const message_1 = require("./entities/message");
const credential_1 = require("./entities/credential");
const claim_1 = require("./entities/claim");
const presentation_1 = require("./entities/presentation");
const utils_1 = require("./utils");
/**
 * This class implements the {@link @veramo/core#IDataStore} interface using a TypeORM compatible database.
 *
 * This allows you to store and retrieve Verifiable Credentials, Presentations and Messages by their IDs.
 *
 * For more complex queries you should use {@link @veramo/data-store#DataStoreORM} which is the default way to query
 * the stored data by some common properties. These two classes MUST also share the same database connection.
 *
 * @see {@link @veramo/core#IDataStoreORM}
 * @see {@link @veramo/core#IDataStore}
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class DataStore {
    constructor(dbConnection) {
        this.schema = core_1.schema.IDataStore;
        this.dbConnection = dbConnection;
        this.methods = {
            dataStoreSaveMessage: this.dataStoreSaveMessage.bind(this),
            dataStoreGetMessage: this.dataStoreGetMessage.bind(this),
            dataStoreDeleteVerifiableCredential: this.dataStoreDeleteVerifiableCredential.bind(this),
            dataStoreSaveVerifiableCredential: this.dataStoreSaveVerifiableCredential.bind(this),
            dataStoreGetVerifiableCredential: this.dataStoreGetVerifiableCredential.bind(this),
            dataStoreSaveVerifiablePresentation: this.dataStoreSaveVerifiablePresentation.bind(this),
            dataStoreGetVerifiablePresentation: this.dataStoreGetVerifiablePresentation.bind(this),
        };
    }
    dataStoreSaveMessage(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(message_1.Message)
                .save((0, message_1.createMessageEntity)(args.message));
            return message.id;
        });
    }
    dataStoreGetMessage(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageEntity = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection)).getRepository(message_1.Message).findOne({
                where: { id: args.id },
                relations: ['credentials', 'presentations'],
            });
            if (!messageEntity)
                throw new Error('not_found: Message not found');
            return (0, message_1.createMessage)(messageEntity);
        });
    }
    dataStoreDeleteVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialEntity = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(credential_1.Credential)
                .findOneBy({ hash: args.hash });
            if (!credentialEntity) {
                return false;
            }
            const claims = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(claim_1.Claim)
                .find({ where: { credential: { id: credentialEntity.id } } });
            yield (yield (0, utils_1.getConnectedDb)(this.dbConnection)).getRepository(claim_1.Claim).remove(claims);
            yield (yield (0, utils_1.getConnectedDb)(this.dbConnection)).getRepository(credential_1.Credential).remove(credentialEntity);
            return true;
        });
    }
    dataStoreSaveVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const verifiableCredential = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(credential_1.Credential)
                .save((0, credential_1.createCredentialEntity)(args.verifiableCredential));
            return verifiableCredential.hash;
        });
    }
    dataStoreGetVerifiableCredential(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialEntity = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(credential_1.Credential)
                .findOneBy({ hash: args.hash });
            if (!credentialEntity)
                throw new Error('not_found: Verifiable credential not found');
            return credentialEntity.raw;
        });
    }
    dataStoreSaveVerifiablePresentation(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const verifiablePresentation = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(presentation_1.Presentation)
                .save((0, presentation_1.createPresentationEntity)(args.verifiablePresentation));
            return verifiablePresentation.hash;
        });
    }
    dataStoreGetVerifiablePresentation(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const presentationEntity = yield (yield (0, utils_1.getConnectedDb)(this.dbConnection))
                .getRepository(presentation_1.Presentation)
                .findOneBy({ hash: args.hash });
            if (!presentationEntity)
                throw new Error('not_found: Verifiable presentation not found');
            return presentationEntity.raw;
        });
    }
}
exports.DataStore = DataStore;
//# sourceMappingURL=data-store.js.map