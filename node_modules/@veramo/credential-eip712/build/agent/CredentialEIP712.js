"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialIssuerEIP712 = void 0;
const utils_1 = require("@veramo/utils");
const index_1 = require("../index");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const eip_712_types_generation_1 = require("eip-712-types-generation");
/**
 * A Veramo plugin that implements the {@link ICredentialIssuerEIP712} methods.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class CredentialIssuerEIP712 {
    constructor() {
        this.schema = index_1.schema.ICredentialIssuerEIP712;
        this.methods = {
            createVerifiableCredentialEIP712: this.createVerifiableCredentialEIP712.bind(this),
            createVerifiablePresentationEIP712: this.createVerifiablePresentationEIP712.bind(this),
            verifyCredentialEIP712: this.verifyCredentialEIP712.bind(this),
            verifyPresentationEIP712: this.verifyPresentationEIP712.bind(this),
        };
    }
    /** {@inheritdoc ICredentialIssuerEIP712.createVerifiableCredentialEIP712} */
    createVerifiableCredentialEIP712(args, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const credentialContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.credential) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const credentialType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.credential) === null || _b === void 0 ? void 0 : _b.type, 'VerifiableCredential');
            let issuanceDate = ((_c = args === null || args === void 0 ? void 0 : args.credential) === null || _c === void 0 ? void 0 : _c.issuanceDate) || new Date().toISOString();
            if (issuanceDate instanceof Date) {
                issuanceDate = issuanceDate.toISOString();
            }
            const issuer = (0, utils_1.extractIssuer)(args.credential);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: credential.issuer must not be empty');
            }
            let keyRef = args.keyRef;
            const identifier = yield context.agent.didManagerGet({ did: issuer });
            if (!keyRef) {
                const key = identifier.keys.find((k) => { var _a, _b; return k.type === 'Secp256k1' && ((_b = (_a = k.meta) === null || _a === void 0 ? void 0 : _a.algorithms) === null || _b === void 0 ? void 0 : _b.includes('eth_signTypedData')); });
                if (!key)
                    throw Error('key_not_found: No suitable signing key is known for ' + identifier.did);
                keyRef = key.kid;
            }
            const extendedKeys = yield (0, utils_1.mapIdentifierKeysToDoc)(identifier, 'verificationMethod', context);
            const extendedKey = extendedKeys.find((key) => key.kid === keyRef);
            if (!extendedKey)
                throw Error('key_not_found: The signing key is not available in the issuer DID document');
            let chainId = 1;
            if (identifier.did.split(':')[1] === 'ethr')
                chainId = (0, utils_1.getChainIdForDidEthr)(extendedKey.meta.verificationMethod);
            const credential = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.credential), { '@context': credentialContext, type: credentialType, issuanceDate, proof: {
                    verificationMethod: extendedKey.meta.verificationMethod.id,
                    created: issuanceDate,
                    proofPurpose: 'assertionMethod',
                    type: 'EthereumEip712Signature2021',
                } });
            const message = credential;
            const domain = {
                chainId,
                name: 'VerifiableCredential',
                version: '1',
            };
            const primaryType = 'VerifiableCredential';
            const allTypes = (0, eip_712_types_generation_1.getEthTypesFromInputDoc)(credential, primaryType);
            const types = Object.assign({}, allTypes);
            const data = JSON.stringify({ domain, types, message, primaryType });
            const signature = yield context.agent.keyManagerSign({ keyRef, data, algorithm: 'eth_signTypedData' });
            credential['proof']['proofValue'] = signature;
            credential['proof']['eip712'] = {
                domain,
                messageSchema: allTypes,
                primaryType,
            };
            return credential;
        });
    }
    /** {@inheritdoc ICredentialIssuerEIP712.verifyCredentialEIP712} */
    verifyCredentialEIP712(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { credential } = args;
            if (!credential.proof || !credential.proof.proofValue)
                throw new Error('invalid_argument: proof is undefined');
            if (!credential.proof.eip712 || !credential.proof.eip712.messageSchema || !credential.proof.eip712.domain)
                throw new Error('invalid_argument: proof.eip712 is missing expected properties');
            const { proof } = credential, signingInput = __rest(credential, ["proof"]);
            const { proofValue, eip712 } = proof, verifyInputProof = __rest(proof, ["proofValue", "eip712"]);
            const verificationMessage = Object.assign(Object.assign({}, signingInput), { proof: verifyInputProof });
            const objectToVerify = {
                message: verificationMessage,
                domain: eip712.domain,
                types: eip712.messageSchema,
                primaryType: eip712.primaryType,
            };
            const recovered = (0, eth_sig_util_1.recoverTypedSignature)({
                data: objectToVerify,
                signature: proofValue,
                version: eth_sig_util_1.SignTypedDataVersion.V4,
            });
            const issuer = (0, utils_1.extractIssuer)(credential);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: credential.issuer must not be empty');
            }
            const didDocument = yield (0, utils_1.resolveDidOrThrow)(issuer, context);
            if (didDocument.verificationMethod) {
                for (const verificationMethod of didDocument.verificationMethod) {
                    if (((_a = (0, utils_1.getEthereumAddress)(verificationMethod)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === recovered.toLowerCase()) {
                        return true;
                    }
                }
            }
            else {
                throw new Error('resolver_error: issuer DIDDocument does not contain any verificationMethods');
            }
            return false;
        });
    }
    /** {@inheritdoc ICredentialIssuerEIP712.createVerifiablePresentationEIP712} */
    createVerifiablePresentationEIP712(args, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const presentationContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.presentation) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const presentationType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.presentation) === null || _b === void 0 ? void 0 : _b.type, 'VerifiablePresentation');
            let issuanceDate = ((_c = args === null || args === void 0 ? void 0 : args.presentation) === null || _c === void 0 ? void 0 : _c.issuanceDate) || new Date().toISOString();
            if (issuanceDate instanceof Date) {
                issuanceDate = issuanceDate.toISOString();
            }
            const presentation = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.presentation), { '@context': presentationContext, type: presentationType, issuanceDate });
            if (!(0, utils_1.isDefined)(args.presentation.holder)) {
                throw new Error('invalid_argument: presentation.holder must not be empty');
            }
            if (args.presentation.verifiableCredential) {
                const credentials = args.presentation.verifiableCredential.map((cred) => {
                    // map JWT credentials to their canonical form
                    if (typeof cred !== 'string' && cred.proof.jwt) {
                        return cred.proof.jwt;
                    }
                    else {
                        return JSON.stringify(cred);
                    }
                });
                presentation.verifiableCredential = credentials;
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: presentation.holder });
            }
            catch (e) {
                throw new Error('invalid_argument: presentation.holder must be a DID managed by this agent');
            }
            let keyRef = args.keyRef;
            if (!keyRef) {
                const key = identifier.keys.find((k) => { var _a, _b; return k.type === 'Secp256k1' && ((_b = (_a = k.meta) === null || _a === void 0 ? void 0 : _a.algorithms) === null || _b === void 0 ? void 0 : _b.includes('eth_signTypedData')); });
                if (!key)
                    throw Error('key_not_found: No suitable signing key is known for ' + identifier.did);
                keyRef = key.kid;
            }
            const extendedKeys = yield (0, utils_1.mapIdentifierKeysToDoc)(identifier, 'verificationMethod', context);
            const extendedKey = extendedKeys.find((key) => key.kid === keyRef);
            if (!extendedKey)
                throw Error('key_not_found: The signing key is not available in the issuer DID document');
            let chainId = 1;
            if (identifier.did.split(':')[1] === 'ethr')
                chainId = (0, utils_1.getChainIdForDidEthr)(extendedKey.meta.verificationMethod);
            presentation['proof'] = {
                verificationMethod: extendedKey.meta.verificationMethod.id,
                created: issuanceDate,
                proofPurpose: 'assertionMethod',
                type: 'EthereumEip712Signature2021',
            };
            const message = presentation;
            const domain = {
                chainId,
                name: 'VerifiablePresentation',
                version: '1',
            };
            const primaryType = 'VerifiablePresentation';
            const allTypes = (0, eip_712_types_generation_1.getEthTypesFromInputDoc)(presentation, primaryType);
            const types = Object.assign({}, allTypes);
            const data = JSON.stringify({ domain, types, message });
            const signature = yield context.agent.keyManagerSign({ keyRef, data, algorithm: 'eth_signTypedData' });
            presentation.proof.proofValue = signature;
            presentation.proof.eip712 = {
                domain,
                messageSchema: allTypes,
                primaryType,
            };
            return presentation;
        });
    }
    /** {@inheritdoc ICredentialIssuerEIP712.verifyPresentationEIP712} */
    verifyPresentationEIP712(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { presentation } = args;
            if (!presentation.proof || !presentation.proof.proofValue)
                throw new Error('Proof is undefined');
            if (!presentation.proof.eip712 ||
                !presentation.proof.eip712.messageSchema ||
                !presentation.proof.eip712.domain)
                throw new Error('proof.eip712 is undefined');
            const { proof } = presentation, signingInput = __rest(presentation, ["proof"]);
            const { proofValue, eip712 } = proof, verifyInputProof = __rest(proof, ["proofValue", "eip712"]);
            const verificationMessage = Object.assign(Object.assign({}, signingInput), { proof: verifyInputProof });
            const objectToVerify = {
                message: verificationMessage,
                domain: eip712.domain,
                types: eip712.messageSchema,
                primaryType: eip712.primaryType,
            };
            const recovered = (0, eth_sig_util_1.recoverTypedSignature)({
                data: objectToVerify,
                signature: proofValue,
                version: eth_sig_util_1.SignTypedDataVersion.V4,
            });
            const issuer = (0, utils_1.extractIssuer)(presentation);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: args.presentation.issuer must not be empty');
            }
            const didDocument = yield (0, utils_1.resolveDidOrThrow)(issuer, context);
            if (didDocument.verificationMethod) {
                for (const verificationMethod of didDocument.verificationMethod) {
                    if (((_a = (0, utils_1.getEthereumAddress)(verificationMethod)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === recovered.toLowerCase()) {
                        return true;
                    }
                }
            }
            else {
                throw new Error('resolver_error: holder DIDDocument does not contain any verificationMethods');
            }
            return false;
        });
    }
}
exports.CredentialIssuerEIP712 = CredentialIssuerEIP712;
//# sourceMappingURL=CredentialEIP712.js.map