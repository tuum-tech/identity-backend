"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyStoreJson = void 0;
const key_manager_1 = require("@veramo/key-manager");
const debug_1 = __importDefault(require("debug"));
const structured_clone_1 = require("@ungap/structured-clone");
const debug = (0, debug_1.default)('veramo:data-store-json:key-store');
/**
 * An implementation of {@link @veramo/key-manager#AbstractKeyStore | AbstractKeyStore} that uses a JSON object to
 * store the relationships between keys, their IDs, aliases and
 * {@link @veramo/key-manager#AbstractKeyManagementSystem | KMS implementations}, as they are known and managed by a
 * Veramo agent.
 *
 * An instance of this class can be used by {@link @veramo/key-manager#KeyManager} as the data storage layer.
 *
 * This class must be initialized with a {@link VeramoJsonStore}, which serves as the JSON object storing data in
 * memory as well as providing an update notification callback to persist this data.
 * For correct usage, this MUST use the same {@link VeramoJsonStore} instance as the one used by
 * {@link @veramo/did-manager#DIDManager | DIDManager}.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class KeyStoreJson extends key_manager_1.AbstractKeyStore {
    /**
     * @param jsonStore - Serves as the JSON object storing data in memory as well as providing an update notification
     *   callback to persist this data. For correct usage, this MUST use the same {@link VeramoJsonStore} instance as the
     *   one used by {@link @veramo/did-manager#DIDManager | DIDManager}.
     */
    constructor(jsonStore) {
        super();
        this.notifyUpdate = jsonStore.notifyUpdate;
        this.cacheTree = jsonStore;
        if (!this.cacheTree.keys) {
            this.cacheTree.keys = {};
        }
    }
    get({ kid }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheTree.keys[kid]) {
                return (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree.keys[kid]));
            }
            else {
                throw Error('not_found: Key not found');
            }
        });
    }
    delete({ kid }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheTree.keys[kid]) {
                const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
                delete this.cacheTree.keys[kid];
                yield this.notifyUpdate(oldTree, this.cacheTree);
                return true;
            }
            else {
                return false;
            }
        });
    }
    import(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const oldTree = (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(this.cacheTree, { lossy: true }));
            this.cacheTree.keys[args.kid] = args;
            yield this.notifyUpdate(oldTree, this.cacheTree);
            return true;
        });
    }
    list(args = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = Object.values(this.cacheTree.keys).map((key) => {
                const { kid, publicKeyHex, type, meta, kms } = key;
                return { kid, publicKeyHex, type, meta: (0, structured_clone_1.deserialize)((0, structured_clone_1.serialize)(meta)), kms };
            });
            return keys;
        });
    }
}
exports.KeyStoreJson = KeyStoreJson;
//# sourceMappingURL=key-store.js.map