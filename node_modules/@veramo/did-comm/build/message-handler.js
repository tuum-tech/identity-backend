"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDCommMessageHandler = void 0;
const message_handler_1 = require("@veramo/message-handler");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('veramo:did-comm:message-handler');
/**
 * A plugin for the {@link @veramo/message-handler#MessageHandler} that decrypts DIDComm messages.
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class DIDCommMessageHandler extends message_handler_1.AbstractMessageHandler {
    constructor() {
        super();
    }
    handleDIDCommAlpha(message, context) {
        const _super = Object.create(null, {
            handle: { get: () => super.handle }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (message.raw) {
                try {
                    const parsed = JSON.parse(message.raw);
                    if (parsed.ciphertext && parsed.protected) {
                        const identifiers = yield context.agent.didManagerFind();
                        for (const identifier of identifiers) {
                            let decrypted;
                            try {
                                const key = identifier.keys.find((k) => k.type === 'Ed25519');
                                if (!key)
                                    throw Error('No encryption keys');
                                decrypted = yield context.agent.keyManagerDecryptJWE({ kid: key.kid, data: message.raw });
                            }
                            catch (e) { }
                            if (decrypted) {
                                debug('Decrypted for %s', identifier.did);
                                debug('Message:', decrypted);
                                try {
                                    const json = JSON.parse(decrypted);
                                    if (json['type'] === 'jwt') {
                                        message.raw = json.body;
                                        message.addMetaData({ type: 'DIDComm' });
                                    }
                                    else {
                                        if (json['id'])
                                            message.id = json['id'];
                                        if (json['type'])
                                            message.type = json['type'];
                                        message.raw = decrypted;
                                        message.data = json;
                                        message.addMetaData({ type: 'DIDComm' });
                                    }
                                    return _super.handle.call(this, message, context);
                                }
                                catch (e) {
                                    debug(e.message);
                                }
                                message.raw = decrypted;
                                message.addMetaData({ type: 'DIDComm' });
                                return _super.handle.call(this, message, context);
                            }
                        }
                    }
                    else if (parsed.type === 'jwt') {
                        message.raw = parsed.body;
                        if (parsed['id'])
                            message.id = parsed['id'];
                        message.addMetaData({ type: 'DIDComm' });
                        return _super.handle.call(this, message, context);
                    }
                    else {
                        message.data = parsed.body;
                        if (parsed['id'])
                            message.id = parsed['id'];
                        if (parsed['type'])
                            message.type = parsed['type'];
                        message.addMetaData({ type: 'DIDComm' });
                        debug('JSON message with id and type', message);
                        return _super.handle.call(this, message, context);
                    }
                }
                catch (e) {
                    debug('Raw message is not a JSON string');
                }
            }
            return _super.handle.call(this, message, context);
        });
    }
    /**
     * Handles a new packed DIDCommV2 Message (also Alpha support but soon deprecated).
     * - Tests whether raw message is a DIDCommV2 message
     * - Unpacks raw message (JWM/JWE/JWS, or plain JSON).
     * -
     */
    handle(message, context) {
        const _super = Object.create(null, {
            handle: { get: () => super.handle }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const rawMessage = message.raw;
            if (rawMessage) {
                // check whether message is DIDCommV2
                let didCommMessageType = undefined;
                try {
                    didCommMessageType = yield context.agent.getDIDCommMessageMediaType({ message: rawMessage });
                }
                catch (e) {
                    debug(`Could not parse message as DIDComm v2: ${e}`);
                }
                if (didCommMessageType) {
                    try {
                        const unpackedMessage = yield context.agent.unpackDIDCommMessage({
                            message: rawMessage,
                        });
                        const { type, to, from, id, thid: threadId, created_time: createdAt, expires_time: expiresAt, body: data, } = unpackedMessage.message;
                        message.type = type;
                        message.to = to;
                        message.from = from;
                        message.id = id;
                        message.threadId = threadId;
                        message.createdAt = createdAt;
                        message.expiresAt = expiresAt;
                        message.data = data;
                        message.addMetaData({ type: 'didCommMetaData', value: JSON.stringify(unpackedMessage.metaData) });
                        context.agent.emit('DIDCommV2Message-received', unpackedMessage);
                        // DIDCommMessageHandler should attempt to forward message to next handler, but 
                        // shouldn't throw an error if other handlers fail
                        let superHandled;
                        try {
                            superHandled = yield _super.handle.call(this, message, context);
                        }
                        catch (e) {
                            debug(`Could not handle DIDCommV2Message in downstream handlers: ${e}`);
                        }
                        // if downstream message handlers failed, still treat original unpacked DIDCommV2Message as good
                        return superHandled || message;
                    }
                    catch (e) {
                        debug(`Could not unpack message as DIDCommV2Message: ${e}`);
                    }
                }
            }
            return this.handleDIDCommAlpha(message, context);
        });
    }
}
exports.DIDCommMessageHandler = DIDCommMessageHandler;
//# sourceMappingURL=message-handler.js.map