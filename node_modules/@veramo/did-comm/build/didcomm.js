"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDComm = void 0;
require("cross-fetch/polyfill");
const did_jwt_1 = require("did-jwt");
const did_resolver_1 = require("did-resolver");
const _1 = require(".");
const uuid_1 = require("uuid");
const u8a = __importStar(require("uint8arrays"));
const utils_1 = require("./utils");
const utils_2 = require("@veramo/utils");
const debug_1 = __importDefault(require("debug"));
const transports_1 = require("./transports/transports");
const message_types_1 = require("./types/message-types");
const debug = (0, debug_1.default)('veramo:did-comm:action-handler');
/**
 * DID Comm plugin for {@link @veramo/core#Agent}
 *
 * This plugin provides a method of creating an encrypted message according to the initial
 * {@link https://github.com/decentralized-identifier/DIDComm-js | DIDComm-js} implementation.
 *
 * @remarks Be advised that this spec is still not final and that this protocol may need to change.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
class DIDComm {
    /**
     * Constructor that takes a list of {@link IDIDCommTransport} objects.
     * @param transports - A list of {@link IDIDCommTransport} objects. Defaults to
     *   {@link @veramo/did-comm#DIDCommHttpTransport | DIDCommHttpTransport}
     */
    constructor(transports = [new transports_1.DIDCommHttpTransport()]) {
        this.schema = _1.schema.IDIDComm;
        this.transports = transports;
        this.methods = {
            sendMessageDIDCommAlpha1: this.sendMessageDIDCommAlpha1.bind(this),
            getDIDCommMessageMediaType: this.getDidCommMessageMediaType.bind(this),
            unpackDIDCommMessage: this.unpackDIDCommMessage.bind(this),
            packDIDCommMessage: this.packDIDCommMessage.bind(this),
            sendDIDCommMessage: this.sendDIDCommMessage.bind(this),
        };
    }
    /** {@inheritdoc IDIDComm.packDIDCommMessage} */
    packDIDCommMessage(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (args.packing) {
                case 'authcrypt': // intentionally omitting break
                case 'anoncrypt':
                    return this.packDIDCommMessageJWE(args, context);
                case 'none':
                    const message = Object.assign(Object.assign({}, args.message), { typ: message_types_1.DIDCommMessageMediaType.PLAIN });
                    return { message: JSON.stringify(message) };
                case 'jws':
                    return this.packDIDCommMessageJWS(args, context);
                default:
                    throw new Error(`not_implemented: packing messages as ${args.packing} is not supported yet`);
            }
        });
    }
    packDIDCommMessageJWS(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = args.message;
            let keyRef = args.keyRef;
            let kid;
            // check that the message has from field that is managed
            let managedSender;
            try {
                managedSender = yield context.agent.didManagerGet({ did: message.from || '' });
            }
            catch (e) {
                debug(`message.from(${message.from}) is not managed by this agent`);
            }
            if (!message.from || !(0, utils_2.isDefined)(managedSender)) {
                throw new Error('invalid_argument: `from` field must be a DID managed by this agent');
            }
            // obtain sender signing key(s) from authentication section
            const senderKeys = yield (0, utils_2.mapIdentifierKeysToDoc)(managedSender, 'authentication', context);
            // try to find a managed signing key that matches keyRef
            let signingKey = null;
            if ((0, utils_2.isDefined)(keyRef)) {
                signingKey = senderKeys.find((key) => key.kid === keyRef || key.meta.verificationMethod.id === keyRef);
            }
            // otherwise use the first available one.
            signingKey = signingKey ? signingKey : senderKeys[0];
            if (!signingKey) {
                throw new Error(`key_not_found: could not locate a suitable signing key for ${message.from}`);
            }
            else {
                kid = signingKey.meta.verificationMethod.id;
            }
            let alg;
            if (signingKey.type === 'Ed25519') {
                alg = 'EdDSA';
            }
            else if (signingKey.type === 'Secp256k1') {
                alg = 'ES256K';
            }
            else {
                throw new Error(`not_supported: key of type ${signingKey.type} is not supported for JWS didcomm message`);
            }
            // construct the protected header with alg, typ and kid
            const headerObj = { alg, kid, typ: message_types_1.DIDCommMessageMediaType.SIGNED };
            const header = (0, utils_2.encodeJoseBlob)(headerObj);
            const payload = (0, utils_2.encodeJoseBlob)(args.message);
            // construct signing input and obtain signature
            const signingInput = header + '.' + payload;
            const signature = yield context.agent.keyManagerSign({
                data: signingInput,
                encoding: 'utf-8',
                keyRef: signingKey.kid,
                algorithm: alg,
            });
            // create flattened JWS
            const packedMessage = {
                protected: header,
                payload,
                signature,
            };
            // serialize flattened JWS JSON and return
            return { message: JSON.stringify(packedMessage) };
        });
    }
    packDIDCommMessageJWE(args, context) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            // 1. check if args.packing requires authentication and map sender key to skid
            let senderECDH = null;
            let keyRef = args.keyRef;
            let protectedHeader = {
                typ: message_types_1.DIDCommMessageMediaType.ENCRYPTED,
            };
            if (args.packing === 'authcrypt') {
                // TODO: what to do about from_prior?
                if (!((_a = args === null || args === void 0 ? void 0 : args.message) === null || _a === void 0 ? void 0 : _a.from)) {
                    throw new Error(`invalid_argument: cannot create authenticated did-comm message without a 'from' field`);
                }
                //    1.1 check that args.message.from is a managed DID
                const sender = yield context.agent.didManagerGet({ did: (_b = args === null || args === void 0 ? void 0 : args.message) === null || _b === void 0 ? void 0 : _b.from });
                //    1.2 match key agreement keys from DID to managed keys
                const senderKeys = yield (0, utils_2.mapIdentifierKeysToDoc)(sender, 'keyAgreement', context);
                // try to find a sender key by keyRef, otherwise pick the first one
                let senderKey;
                if ((0, utils_2.isDefined)(keyRef)) {
                    senderKey = senderKeys.find((key) => key.kid === keyRef || key.meta.verificationMethod.id === keyRef);
                }
                senderKey = senderKey || senderKeys[0];
                //    1.3 use kid from DID doc(skid) + local IKey to bundle a sender key
                if (senderKey) {
                    senderECDH = (0, utils_1.createEcdhWrapper)(senderKey.kid, context);
                    protectedHeader = Object.assign(Object.assign({}, protectedHeader), { skid: senderKey.meta.verificationMethod.id });
                }
                else {
                    throw new Error(`key_not_found: could not map an agent key to an skid for ${(_c = args === null || args === void 0 ? void 0 : args.message) === null || _c === void 0 ? void 0 : _c.from}`);
                }
            }
            let recipients = [];
            function computeRecipients(to) {
                return __awaiter(this, void 0, void 0, function* () {
                    // 2.1 resolve DID for "to"
                    const didDocument = yield (0, utils_2.resolveDidOrThrow)(to, context);
                    // 2.2 extract all recipient key agreement keys and normalize them
                    const keyAgreementKeys = (yield (0, utils_2.dereferenceDidKeys)(didDocument, 'keyAgreement', context)).filter((k) => { var _a; return ((_a = k.publicKeyHex) === null || _a === void 0 ? void 0 : _a.length) > 0; });
                    if (keyAgreementKeys.length === 0) {
                        throw new Error(`key_not_found: no key agreement keys found for recipient ${to}`);
                    }
                    // 2.3 get public key bytes and key IDs for supported recipient keys
                    const tempRecipients = keyAgreementKeys
                        .map((pk) => ({ kid: pk.id, publicKeyBytes: u8a.fromString(pk.publicKeyHex, 'base16') }))
                        .filter(utils_2.isDefined);
                    if (tempRecipients.length === 0) {
                        throw new Error(`not_supported: no compatible key agreement keys found for recipient ${to}`);
                    }
                    return tempRecipients;
                });
            }
            // add primary recipient
            recipients.push(...(yield computeRecipients(args.message.to)));
            // add bcc recipients (optional)
            for (const to of ((_d = args.options) === null || _d === void 0 ? void 0 : _d.bcc) || []) {
                recipients.push(...(yield computeRecipients(to)));
            }
            // 3. create Encrypter for each recipient
            const encrypters = recipients
                .map((recipient) => {
                if (args.packing === 'authcrypt') {
                    return (0, did_jwt_1.createAuthEncrypter)(recipient.publicKeyBytes, senderECDH, { kid: recipient.kid });
                }
                else {
                    return (0, did_jwt_1.createAnonEncrypter)(recipient.publicKeyBytes, { kid: recipient.kid });
                }
            })
                .filter(utils_2.isDefined);
            if (encrypters.length === 0) {
                throw new Error(`not_supported: could not create suitable encryption for recipient ${(_e = args === null || args === void 0 ? void 0 : args.message) === null || _e === void 0 ? void 0 : _e.to}`);
            }
            // 4. createJWE
            const messageBytes = u8a.fromString(JSON.stringify(args.message), 'utf-8');
            const jwe = yield (0, did_jwt_1.createJWE)(messageBytes, encrypters, protectedHeader);
            const message = JSON.stringify(jwe);
            return { message };
        });
    }
    /** {@inheritdoc IDIDComm.getDIDCommMessageMediaType} */
    getDidCommMessageMediaType({ message }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { mediaType } = this.decodeMessageAndMediaType(message);
                return mediaType;
            }
            catch (e) {
                debug(`Could not parse message as DIDComm v2 message: ${e}`);
                throw e;
            }
        });
    }
    /** {@inheritdoc IDIDComm.unpackDIDCommMessage} */
    unpackDIDCommMessage(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { msgObj, mediaType } = this.decodeMessageAndMediaType(args.message);
            if (mediaType === message_types_1.DIDCommMessageMediaType.SIGNED) {
                return this.unpackDIDCommMessageJWS(msgObj, context);
            }
            else if (mediaType === message_types_1.DIDCommMessageMediaType.PLAIN) {
                return { message: msgObj, metaData: { packing: 'none' } };
            }
            else if (mediaType === message_types_1.DIDCommMessageMediaType.ENCRYPTED) {
                return this.unpackDIDCommMessageJWE({ jwe: msgObj }, context);
            }
            else {
                throw Error('not_supported: ' + mediaType);
            }
        });
    }
    unpackDIDCommMessageJWS(jws, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: currently only supporting one signature
            const signatureEncoded = (0, utils_2.isDefined)(jws.signature)
                ? jws.signature
                : (_a = jws.signatures[0]) === null || _a === void 0 ? void 0 : _a.signature;
            const headerEncoded = (0, utils_2.isDefined)(jws.protected)
                ? jws.protected
                : (_b = jws.signatures[0]) === null || _b === void 0 ? void 0 : _b.protected;
            if (!(0, utils_2.isDefined)(headerEncoded) || !(0, utils_2.isDefined)(signatureEncoded)) {
                throw new Error('invalid_argument: could not interpret message as JWS');
            }
            const message = (0, utils_2.decodeJoseBlob)(jws.payload);
            const header = (0, utils_2.decodeJoseBlob)(headerEncoded);
            const sender = (_c = (0, did_resolver_1.parse)(header.kid)) === null || _c === void 0 ? void 0 : _c.did;
            if (!(0, utils_2.isDefined)(sender) || sender !== message.from) {
                throw new Error('invalid_jws: sender is not a DID or does not match the `kid`');
            }
            const senderDoc = yield (0, utils_2.resolveDidOrThrow)(sender, context);
            const senderKey = (yield context.agent.getDIDComponentById({
                didDocument: senderDoc,
                didUrl: header.kid,
                section: 'authentication',
            }));
            const verifiedSenderKey = (0, did_jwt_1.verifyJWS)(`${headerEncoded}.${jws.payload}.${signatureEncoded}`, senderKey);
            if ((0, utils_2.isDefined)(verifiedSenderKey)) {
                return { message, metaData: { packing: 'jws' } };
            }
            else {
                throw new Error('invalid_jws: sender `kid` could not be validated as the signer of the message');
            }
        });
    }
    unpackDIDCommMessageJWE({ jwe }, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // 0 resolve skid to DID doc
            //   - find skid in DID doc and convert to 'X25519' byte array (if type matches)
            let senderKeyBytes = yield (0, utils_1.extractSenderEncryptionKey)(jwe, context);
            // 1. check whether kid is one of my DID URIs
            //   - get recipient DID URIs
            //   - extract DIDs from recipient DID URIs
            //   - match DIDs against locally managed DIDs
            let managedRecipients = yield (0, utils_1.extractManagedRecipients)(jwe, context);
            // 2. get internal IKey instance for each recipient.kid
            //   - resolve locally managed DIDs that match recipients
            //   - filter to the keyAgreementKeys that match the recipient.kid
            //   - match identifier.keys.publicKeyHex to (verificationMethod.publicKey*)
            //   - return a list of `IKey`
            const localKeys = yield (0, utils_1.mapRecipientsToLocalKeys)(managedRecipients, context);
            // 3. for each recipient
            //  if isAuthcrypted? (if senderKey != null)
            //   - construct auth decrypter
            //  else
            //   - construct anon decrypter
            for (const localKey of localKeys) {
                let packing;
                let decrypter;
                const recipientECDH = (0, utils_1.createEcdhWrapper)(localKey.localKeyRef, context);
                // TODO: here's where more algorithms should be supported
                if (senderKeyBytes && ((_c = (_b = (_a = localKey.recipient) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.alg) === null || _c === void 0 ? void 0 : _c.includes('ECDH-1PU'))) {
                    decrypter = (0, did_jwt_1.createAuthDecrypter)(recipientECDH, senderKeyBytes);
                    packing = 'authcrypt';
                }
                else {
                    decrypter = (0, did_jwt_1.createAnonDecrypter)(recipientECDH);
                    packing = 'anoncrypt';
                }
                // 4. decryptJWE(jwe, decrypter)
                try {
                    const decryptedBytes = yield (0, did_jwt_1.decryptJWE)(jwe, decrypter);
                    const decryptedMsg = u8a.toString(decryptedBytes, 'utf-8');
                    const message = JSON.parse(decryptedMsg);
                    return { message, metaData: { packing } };
                }
                catch (e) {
                    debug(`unable to decrypt DIDComm msg using ${localKey.localKeyRef} (${localKey.recipient.header.kid})`);
                }
            }
            throw new Error('unable to decrypt DIDComm message with any of the locally managed keys');
        });
    }
    decodeMessageAndMediaType(message) {
        let msgObj;
        if (typeof message === 'string') {
            try {
                msgObj = JSON.parse(message);
            }
            catch (e) {
                throw new Error('invalid_argument: unable to parse message as JSON');
                // TODO: try to interpret as compact serialized JWS / JWM?
            }
        }
        else {
            msgObj = message;
        }
        let mediaType = null;
        if (msgObj.typ === message_types_1.DIDCommMessageMediaType.PLAIN) {
            mediaType = message_types_1.DIDCommMessageMediaType.PLAIN;
        }
        else if (msgObj.protected) {
            const protectedHeader = (0, utils_2.decodeJoseBlob)(msgObj.protected);
            if (protectedHeader.typ === message_types_1.DIDCommMessageMediaType.SIGNED) {
                mediaType = message_types_1.DIDCommMessageMediaType.SIGNED;
            }
            else if (protectedHeader.typ === message_types_1.DIDCommMessageMediaType.ENCRYPTED) {
                mediaType = message_types_1.DIDCommMessageMediaType.ENCRYPTED;
            }
            else {
                throw new Error('invalid_argument: unable to determine message type');
            }
        }
        else if (msgObj.signatures) {
            mediaType = message_types_1.DIDCommMessageMediaType.SIGNED;
        }
        else {
            throw new Error('invalid_argument: unable to determine message type');
        }
        return { msgObj, mediaType };
    }
    findPreferredDIDCommService(services) {
        // FIXME: TODO: get preferred service endpoint according to configuration; now defaulting to first service
        return services[0];
    }
    /** {@inheritdoc IDIDComm.sendDIDCommMessage} */
    sendDIDCommMessage(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { packedMessage, returnTransportId, recipientDidUrl, messageId } = args;
            if (returnTransportId) {
                // FIXME: TODO: check if previous message was ok with reusing transport?
                // if so, retrieve transport from transport manager
                //transport = this.findDIDCommTransport(returnTransportId)
                throw new Error(`not_supported: return routes not supported yet`);
            }
            const didDoc = yield (0, utils_2.resolveDidOrThrow)(recipientDidUrl, context);
            const services = (_a = didDoc.service) === null || _a === void 0 ? void 0 : _a.filter((service) => service.type === 'DIDCommMessaging');
            if (!services || services.length === 0) {
                throw new Error(`not_found: could not find DIDComm Messaging service in DID document for '${recipientDidUrl}'`);
            }
            const service = this.findPreferredDIDCommService(services);
            if (!service) {
                throw new Error(`not_found: could not find preferred DIDComm Messaging service in DID document for '${recipientDidUrl}'`);
            }
            // FIXME: TODO: wrap forward messages based on service entry
            const transports = this.transports.filter((t) => t.isServiceSupported(service) && (!returnTransportId || t.id === returnTransportId));
            if (!transports || transports.length < 1) {
                throw new Error('not_found: no transport type found for service: ' + JSON.stringify(service));
            }
            // TODO: better strategy for selecting the transport if multiple transports apply
            const transport = transports[0];
            try {
                const response = yield transport.send(service, packedMessage.message);
                if (response.error) {
                    throw new Error(`Error when sending DIDComm message through transport with id: '${transport.id}': ${response.error}`);
                }
            }
            catch (e) {
                throw new Error(`Cannot send DIDComm message through transport with id: '${transport.id}': ${e}`);
            }
            context.agent.emit('DIDCommV2Message-sent', messageId);
            return transport.id;
        });
    }
    /** {@inheritdoc IDIDComm.sendMessageDIDCommAlpha1} */
    sendMessageDIDCommAlpha1(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { data, url, headers, save = true } = args;
            debug('Resolving didDoc');
            const didDoc = (yield context.agent.resolveDid({ didUrl: data.to })).didDocument;
            let serviceEndpoint;
            if (url) {
                serviceEndpoint = url;
            }
            else {
                const service = didDoc && didDoc.service && didDoc.service.find((item) => item.type == 'Messaging');
                serviceEndpoint = service === null || service === void 0 ? void 0 : service.serviceEndpoint;
            }
            if (serviceEndpoint) {
                try {
                    data.id = data.id || (0, uuid_1.v4)();
                    let postPayload = JSON.stringify(data);
                    try {
                        const identifier = yield context.agent.didManagerGet({ did: data.from });
                        const key = identifier.keys.find((k) => k.type === 'Ed25519');
                        if (!key)
                            throw Error('No encryption key');
                        const publicKey = (_a = didDoc === null || didDoc === void 0 ? void 0 : didDoc.publicKey) === null || _a === void 0 ? void 0 : _a.find((item) => item.type == 'Ed25519VerificationKey2018');
                        if (!(publicKey === null || publicKey === void 0 ? void 0 : publicKey.publicKeyHex))
                            throw Error('Recipient does not have encryption publicKey');
                        postPayload = yield context.agent.keyManagerEncryptJWE({
                            kid: key.kid,
                            to: {
                                type: 'Ed25519',
                                publicKeyHex: publicKey === null || publicKey === void 0 ? void 0 : publicKey.publicKeyHex,
                                kid: publicKey === null || publicKey === void 0 ? void 0 : publicKey.publicKeyHex,
                            },
                            data: postPayload,
                        });
                        debug('Encrypted:', postPayload);
                    }
                    catch (e) {
                    }
                    debug('Sending to %s', serviceEndpoint);
                    const endpointUri = (typeof serviceEndpoint === 'string') ? serviceEndpoint : serviceEndpoint.uri;
                    const res = yield fetch(endpointUri, {
                        method: 'POST',
                        body: postPayload,
                        headers,
                    });
                    debug('Status', res.status, res.statusText);
                    if (res.status == 200) {
                        return yield context.agent.handleMessage({
                            raw: JSON.stringify(data),
                            metaData: [{ type: 'DIDComm-sent' }],
                            save,
                        });
                    }
                    return Promise.reject(new Error('Message not sent'));
                }
                catch (e) {
                    return Promise.reject(e);
                }
            }
            else {
                debug('No Messaging service in didDoc');
                return Promise.reject(new Error('No service endpoint'));
            }
        });
    }
}
exports.DIDComm = DIDComm;
//# sourceMappingURL=didcomm.js.map