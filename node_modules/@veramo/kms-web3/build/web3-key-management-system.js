"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3KeyManagementSystem = void 0;
const key_manager_1 = require("@veramo/key-manager");
const strings_1 = require("@ethersproject/strings");
/**
 * This is a {@link @veramo/key-manager#AbstractKeyManagementSystem | KMS} implementation that uses the addresses of a
 * web3 wallet as key identifiers, and calls the respective wallet for signing operations.
 * @beta
 */
class Web3KeyManagementSystem extends key_manager_1.AbstractKeyManagementSystem {
    /**
     *
     * @param providers - the key can be any unique name.
     * Example `{ metamask: metamaskProvider, walletConnect: walletConnectProvider }`
     */
    constructor(providers) {
        super();
        this.providers = providers;
    }
    createKey({ type }) {
        throw Error('not_supported: Web3KeyManagementSystem cannot create new keys');
    }
    importKey(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // throw Error('Not implemented')
            return args;
        });
    }
    listKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = [];
            for (const provider in this.providers) {
                const accounts = yield this.providers[provider].listAccounts();
                for (const account of accounts) {
                    const key = {
                        kid: `${provider}-${account}`,
                        type: 'Secp256k1',
                        publicKeyHex: '',
                        kms: '',
                        meta: {
                            account,
                            provider,
                            algorithms: ['eth_signMessage', 'eth_signTypedData'],
                        },
                    };
                    keys.push(key);
                }
            }
            return keys;
        });
    }
    sharedSecret(args) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error('not_implemented: Web3KeyManagementSystem sharedSecret');
        });
    }
    deleteKey(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // this kms doesn't need to delete keys
            return true;
        });
    }
    // keyRef should be in this format '{providerName-account}
    // example: 'metamask-0xf3beac30c498d9e26865f34fcaa57dbb935b0d74'
    getAccountAndSignerByKeyRef(keyRef) {
        const [providerName, account] = keyRef.kid.split('-');
        if (!this.providers[providerName]) {
            throw Error(`not_available: provider ${providerName}`);
        }
        const signer = this.providers[providerName].getSigner(account);
        return { account, signer };
    }
    sign({ keyRef, algorithm, data, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (algorithm) {
                if (algorithm === 'eth_signMessage') {
                    return yield this.eth_signMessage(keyRef, data);
                }
                else if (['eth_signTypedData', 'EthereumEip712Signature2021'].includes(algorithm)) {
                    return yield this.eth_signTypedData(keyRef, data);
                }
            }
            throw Error(`not_supported: Cannot sign ${algorithm} `);
        });
    }
    /**
     * @returns a `0x` prefixed hex string representing the signed EIP712 data
     */
    eth_signTypedData(keyRef, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let msg, msgDomain, msgTypes, msgPrimaryType;
            const serializedData = (0, strings_1.toUtf8String)(data);
            try {
                const jsonData = JSON.parse(serializedData);
                if (typeof jsonData.domain === 'object' && typeof jsonData.types === 'object') {
                    const { domain, types, message, primaryType } = jsonData;
                    msg = message;
                    msgDomain = domain;
                    msgTypes = types;
                    msgPrimaryType = primaryType;
                }
                else {
                    // next check will throw since the data couldn't be parsed
                }
            }
            catch (e) {
                // next check will throw since the data couldn't be parsed
            }
            if (typeof msgDomain !== 'object' || typeof msgTypes !== 'object' || typeof msg !== 'object') {
                throw Error(`invalid_arguments: Cannot sign typed data. 'domain', 'types', and 'message' must be provided`);
            }
            delete msgTypes.EIP712Domain;
            const { signer } = this.getAccountAndSignerByKeyRef(keyRef);
            const signature = yield signer._signTypedData(msgDomain, msgTypes, msg);
            return signature;
        });
    }
    /**
     * @returns a `0x` prefixed hex string representing the signed message
     */
    eth_signMessage(keyRef, rawMessageBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const { signer } = this.getAccountAndSignerByKeyRef(keyRef);
            const signature = yield signer.signMessage(rawMessageBytes);
            // HEX encoded string, 0x prefixed
            return signature;
        });
    }
}
exports.Web3KeyManagementSystem = Web3KeyManagementSystem;
//# sourceMappingURL=web3-key-management-system.js.map