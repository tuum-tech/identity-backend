"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandler = exports.EventTypes = void 0;
const core_1 = require("@veramo/core");
const message_1 = require("./message");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('veramo:message-handler');
exports.EventTypes = {
    validatedMessage: 'validatedMessage',
    savedMessage: 'savedMessage',
    error: core_1.CoreEvents.error,
};
/**
 * A Veramo agent plugin that implements {@link @veramo/core#IMessageHandler | IMessageHandler} methods.
 *
 * This plugin is meant to chain together multiple other {@link @veramo/core#IMessageHandler | IMessageHandler}
 * implementations.
 *
 * When handling a message, the message is passed from one handler to the next, and each handler in
 * the chain can decide if it is able to interpret the message.
 *
 * If the message can be processed by a handler it is returned as an {@link @veramo/core#IMessage | IMessage}.
 * If the message cannot be processed by any of the handlers, an error is thrown.
 *
 * @public
 */
class MessageHandler {
    constructor(options) {
        this.schema = core_1.schema.IMessageHandler;
        for (const messageHandler of options.messageHandlers) {
            if (!this.messageHandler) {
                this.messageHandler = messageHandler;
            }
            else {
                let lastHandler = this.messageHandler;
                while (lastHandler.nextMessageHandler !== undefined) {
                    lastHandler = lastHandler.nextMessageHandler;
                }
                lastHandler.setNext(messageHandler);
            }
        }
        this.handleMessage = this.handleMessage.bind(this);
        this.methods = {
            handleMessage: this.handleMessage,
        };
    }
    /** {@inheritDoc @veramo/core#IMessageHandler.handleMessage} */
    handleMessage(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { raw, metaData, save } = args;
            debug('%o', { raw, metaData, save });
            if (!this.messageHandler) {
                return Promise.reject(new Error('Message handler not provided'));
            }
            try {
                const message = yield this.messageHandler.handle(new message_1.Message({ raw, metaData }), context);
                if (message.isValid()) {
                    debug('Emitting event', exports.EventTypes.validatedMessage);
                    context.agent.emit(exports.EventTypes.validatedMessage, message);
                }
                debug('Validated message %o', message);
                if (save) {
                    yield context.agent.dataStoreSaveMessage({ message });
                    debug('Emitting event', exports.EventTypes.savedMessage);
                    context.agent.emit(exports.EventTypes.savedMessage, message);
                }
                return message;
            }
            catch (error) {
                debug('Error', error);
                context.agent.emit(exports.EventTypes.error, error);
                return Promise.reject(error);
            }
        });
    }
}
exports.MessageHandler = MessageHandler;
//# sourceMappingURL=message-handler.js.map